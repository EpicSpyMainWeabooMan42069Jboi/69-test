import os
import sys
import time
import random
import string
import ctypes
import logging
import psutil
import pymem
import pymem.process
from ctypes import wintypes
from datetime import datetime
import tkinter as tk
from tkinter import messagebox, simpledialog


# Set up logging
logging.basicConfig(
    filename='sv_cheats_bypass_log.txt',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filemode='w'
)


# Constants for Windows API
WH_KEYBOARD_LL = 13
WM_KEYDOWN = 0x0100
VK_INSERT = 0x2D


# Memory protection constants
PAGE_EXECUTE_READWRITE = 0x40
PAGE_READWRITE = 0x04


# Global variables
bypass_active = False
keyboard_hook = None
pm = None  # Pymem instance
game_process = None
sv_cheats_address = None
original_flags = 0
original_value = 0


# ConVar offsets - these would need to be updated for specific games
CONVAR_NAME_OFFSET = 0x0C
CONVAR_FLAGS_OFFSET = 0x14
CONVAR_VALUE_OFFSET = 0x30
CONVAR_FLOAT_VALUE_OFFSET = 0x2C
CONVAR_STRING_OFFSET = 0x24


# Flag definitions
FCVAR_UNREGISTERED = (1 << 0)
FCVAR_DEVELOPMENTONLY = (1 << 1)
FCVAR_GAMEDLL = (1 << 2)
FCVAR_CLIENTDLL = (1 << 3)
FCVAR_CHEAT = (1 << 4)
FCVAR_PROTECTED = (1 << 5)
FCVAR_SPONLY = (1 << 6)
FCVAR_ARCHIVE = (1 << 7)
FCVAR_REPLICATED = (1 << 8)


def change_memory_protection(address, size, new_protection):
    """Change memory protection for a region"""
    try:
        old_protection = wintypes.DWORD()
        result = ctypes.windll.kernel32.VirtualProtectEx(
            pm.process_handle,
            ctypes.c_void_p(address),
            size,
            new_protection,
            ctypes.byref(old_protection)
        )
        if result:
            return old_protection.value
        else:
            error = ctypes.windll.kernel32.GetLastError()
            logging.error(f"VirtualProtectEx failed with error: {error}")
            return None
    except Exception as e:
        logging.error(f"Exception in change_memory_protection: {str(e)}")
        return None


def safe_write_memory(address, value, value_type="int"):
    """Safely write to protected memory"""
    try:
        size = 4 if value_type in ["int", "float"] else len(value) if isinstance(value, bytes) else 4
        old_protection = change_memory_protection(address, size, PAGE_READWRITE)
        if old_protection is None:
            return False
        if value_type == "int":
            pm.write_int(address, value)
        elif value_type == "float":
            pm.write_float(address, value)
        elif value_type == "bytes":
            pm.write_bytes(address, value, len(value))
        change_memory_protection(address, size, old_protection)
        return True
    except Exception as e:
        logging.error(f"Exception in safe_write_memory: {str(e)}")
        return False


def find_convar_improved(name):
    """Improved ConVar finding with better validation"""
    try:
        logging.info(f"Looking for ConVar: {name}")
        target_modules = ["engine.dll", "server.dll", "client.dll", "tier0.dll"]
        for module in pm.list_modules():
            if any(target in module.name.lower() for target in target_modules):
                logging.info(f"Scanning module: {module.name}")
                pattern = name.encode('ascii') + b'\x00'
                try:
                    matches = pymem.pattern.pattern_scan_module(
                        pm.process_handle,
                        module,
                        pattern
                    )
                    if matches:
                        for match in [matches] if not isinstance(matches, list) else matches:
                            convar_addr = validate_convar_structure(match, name)
                            if convar_addr:
                                return convar_addr
                except Exception as e:
                    logging.warning(f"Error scanning {module.name}: {str(e)}")
                    continue
        return None
    except Exception as e:
        logging.error(f"Error in find_convar_improved: {str(e)}")
        return None


def validate_convar_structure(name_addr, expected_name):
    """Validate that an address points to a valid ConVar"""
    try:
        possible_bases = [
            name_addr - CONVAR_NAME_OFFSET,
            name_addr - 0x04,
            name_addr - 0x08,
        ]
        for base_addr in possible_bases:
            try:
                flags = pm.read_int(base_addr + CONVAR_FLAGS_OFFSET)
                if flags < 0 or flags > 0x10000:
                    continue
                try:
                    read_name = pm.read_string(base_addr + CONVAR_NAME_OFFSET, len(expected_name) + 1)
                    if read_name.lower() == expected_name.lower():
                        logging.info(f"Validated ConVar {expected_name} at 0x{base_addr:X}")
                        return base_addr
                except:
                    pass
            except Exception:
                continue
        return None
    except Exception as e:
        logging.error(f"Error validating ConVar structure: {str(e)}")
        return None


def elevate_process_privileges():
    """Attempt to get debug privileges"""
    try:
        import ctypes.wintypes
        token = ctypes.wintypes.HANDLE()
        ctypes.windll.advapi32.OpenProcessToken(
            ctypes.windll.kernel32.GetCurrentProcess(),
            0x0020,  # TOKEN_ADJUST_PRIVILEGES
            ctypes.byref(token)
        )
        privilege = ctypes.c_uint64(0x0000000000000014)  # SE_DEBUG_PRIVILEGE
        ctypes.windll.advapi32.LookupPrivilegeValueW(
            None, "SeDebugPrivilege", ctypes.byref(privilege)
        )
        return True
    except Exception as e:
        logging.warning(f"Could not elevate privileges: {str(e)}")
        return False


def random_string(length):
    """Generate a random string of fixed length"""
    letters = string.ascii_letters
    return ''.join(random.choice(letters) for _ in range(length))


def find_game_process(game_names):
    """Find the game process by name"""
    try:
        for proc in psutil.process_iter(['pid', 'name']):
            for game_name in game_names:
                if game_name.lower() in proc.info['name'].lower():
                    logging.info(f"Found game process: {proc.info['name']} (PID: {proc.info['pid']})")
                    return proc.info['pid']
        return None
    except Exception as e:
        logging.error(f"Error finding game process: {str(e)}")
        return None


def find_cvar_interface():
    """Find the ICvar interface in the game memory"""
    try:
        logging.info("Looking for ICvar interface...")
        vstdlib = None
        for module in pm.list_modules():
            if module.name.lower() == "vstdlib.dll":
                vstdlib = module
                break
        if not vstdlib:
            logging.error("vstdlib.dll not found")
            return None
        logging.info(f"Found vstdlib.dll at 0x{vstdlib.lpBaseOfDll:X}")
        create_interface = pm.read_bytes(vstdlib.lpBaseOfDll, 0x1000)
        logging.info("Successfully found ICvar interface (simulated)")
        return True
    except Exception as e:
        logging.error(f"Error finding ICvar interface: {str(e)}")
        return None


def enable_sv_cheats_bypass():
    global bypass_active, original_flags, original_value
    try:
        if not sv_cheats_address:
            messagebox.showerror("Error", "sv_cheats ConVar not found!")
            return
        logging.info("Attempting to enable sv_cheats bypass...")
        try:
            original_flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
            original_value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
        except Exception as e:
            logging.error(f"Failed to read original values: {str(e)}")
            return
        logging.info(f"Original sv_cheats flags: 0x{original_flags:X}, value: {original_value}")
        new_flags = original_flags
        new_flags &= ~FCVAR_CHEAT
        new_flags &= ~FCVAR_REPLICATED
        new_flags &= ~FCVAR_PROTECTED
        new_flags &= ~FCVAR_SPONLY
        if not safe_write_memory(sv_cheats_address + CONVAR_FLAGS_OFFSET, new_flags, "int"):
            messagebox.showerror("Error", "Failed to modify ConVar flags!")
            return
        if not safe_write_memory(sv_cheats_address + CONVAR_VALUE_OFFSET, 1, "int"):
            messagebox.showerror("Error", "Failed to modify ConVar value!")
            return
        if not safe_write_memory(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET, 1.0, "float"):
            logging.warning("Failed to modify float value, but continuing...")
        current_flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
        current_value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
        logging.info(f"After bypass: flags=0x{current_flags:X}, value={current_value}")
        bypass_active = True
        messagebox.showinfo("Success", "sv_cheats bypass ENABLED")
    except Exception as e:
        logging.error(f"Exception in enable_sv_cheats_bypass: {str(e)}")
        messagebox.showerror("Error", f"Failed to enable bypass: {str(e)}")

def disable_sv_cheats_bypass():
    global bypass_active
    
    try:
        if not sv_cheats_address:
            return
            
        logging.info("Attempting to disable sv_cheats bypass...")
        
        # Restore original flags and value
        pm.write_int(sv_cheats_address + CONVAR_FLAGS_OFFSET, original_flags)
        pm.write_int(sv_cheats_address + CONVAR_VALUE_OFFSET, original_value)
        pm.write_float(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET, float(original_value))
        
        # Verify the changes
        current_flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
        current_value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
        
        logging.info(f"After restore: sv_cheats flags = 0x{current_flags:X}, value = {current_value}")
        
        bypass_active = False
        messagebox.showinfo("Status", "sv_cheats bypass DISABLED")
    except Exception as e:
        logging.error(f"Exception in disable_sv_cheats_bypass: {str(e)}")

def toggle_sv_cheats_bypass():
    try:
        logging.info("Toggle function called")
        if not bypass_active:
            enable_sv_cheats_bypass()
        else:
            disable_sv_cheats_bypass()
    except Exception as e:
        logging.error(f"Exception in toggle_sv_cheats_bypass: {str(e)}")

# Keyboard hook callback function
def low_level_keyboard_handler(nCode, wParam, lParam):
    try:
        if nCode >= 0 and wParam == WM_KEYDOWN:
            kb_struct = ctypes.cast(lParam, ctypes.POINTER(ctypes.c_ulong))
            vk_code = kb_struct[0]
            
            # Check for INSERT key
            if vk_code == VK_INSERT:
                logging.info("INSERT key detected!")
                toggle_sv_cheats_bypass()
                return 1  # Prevent other hooks from processing this key
    except Exception as e:
        logging.error(f"Exception in keyboard handler: {str(e)}")
    
    # Call the next hook
    return ctypes.windll.user32.CallNextHookEx(keyboard_hook, nCode, wParam, lParam)

def set_keyboard_hook():
    global keyboard_hook
    
    try:
        logging.info("Setting up keyboard hook")
        
        # Define the callback function type
        CMPFUNC = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_void_p))
        pointer = CMPFUNC(low_level_keyboard_handler)
        
        # Set the hook
        keyboard_hook = ctypes.windll.user32.SetWindowsHookExA(
            WH_KEYBOARD_LL, 
            pointer, 
            ctypes.windll.kernel32.GetModuleHandleA(None), 
            0
        )
        
        if not keyboard_hook:
            logging.error("Failed to set keyboard hook!")
            messagebox.showerror("Error", "Failed to set keyboard hook!")
            return False
            
        logging.info("Keyboard hook set up successfully")
        return True
    except Exception as e:
        logging.error(f"Exception in set_keyboard_hook: {str(e)}")
        return False

def cleanup():
    global keyboard_hook, pm
    
    try:
        logging.info("Cleaning up resources")
        
        # Disable the bypass if active
        if bypass_active:
            disable_sv_cheats_bypass()
        
        # Unhook keyboard hook
        if keyboard_hook:
            ctypes.windll.user32.UnhookWindowsHookEx(keyboard_hook)
            keyboard_hook = None
        
        # Close Pymem instance
        if pm:
            pm.close_process()
            
        logging.info("Cleanup complete")
    except Exception as e:
        logging.error(f"Exception in cleanup: {str(e)}")

def initialize():
    global pm, sv_cheats_address
    
    try:
        
        # Try to elevate privileges first 
  
         elevate_process_privileges()
       
        # Clear log file
         with open('sv_cheats_bypass_log.txt', 'w') as f:
            f.write("Initializing sv_cheats bypass plugin...\n")
        
        # Set random seed
        random.seed(time.time())
        
        # Find game process
        game_names = ["hl2.exe", "csgo.exe", "portal2.exe", "left4dead2.exe", "tf_win64.exe"]
        game_pid = find_game_process(game_names)
        
        if not game_pid:
            logging.error("Game process not found!")
            messagebox.showerror("Error", "Game process not found! Make sure the game is running.")
            return False
        
        # Open the process
        try:
            pm = pymem.Pymem(game_pid)
            logging.info(f"Successfully opened game process (PID: {game_pid})")
        except Exception as e:
            logging.error(f"Failed to open game process: {str(e)}")
            messagebox.showerror("Error", f"Failed to open game process: {str(e)}")
            return False
        
        # Find ICvar interface
        if not find_cvar_interface():
            logging.error("Failed to find ICvar interface!")
            messagebox.showerror("Error", "Failed to find ICvar interface!")
            return False
        
        # Find sv_cheats ConVar
        sv_cheats_address = find_convar("sv_cheats")
        if not sv_cheats_address:
            logging.error("Failed to find sv_cheats ConVar!")
            messagebox.showerror("Error", "Failed to find sv_cheats ConVar!")
            return False
        
        # Set up keyboard hook
        if not set_keyboard_hook():
            return False
        
        messagebox.showinfo("Plugin Loaded", "sv_cheats Bypass Plugin Loaded!\nPress INSERT key to toggle bypass.")
        return True
    except Exception as e:
        logging.error(f"Exception in initialize: {str(e)}")
        messagebox.showerror("Error", f"Initialization error: {str(e)}")
        return False

class SvCheatsApp:
    def __init__(self, root):
        self.root = root
        self.root.title("sv_cheats Bypass Tool")
        self.root.geometry("400x300")
        self.root.resizable(False, False)
        
        # Create UI elements
        self.label = tk.Label(root, text="sv_cheats Bypass Tool", font=("Arial", 14, "bold"))
        self.label.pack(pady=10)
        
        self.game_label = tk.Label(root, text="Game: Not connected", font=("Arial", 10))
        self.game_label.pack(pady=5)
        
        self.status_label = tk.Label(root, text="Status: Inactive", font=("Arial", 12))
        self.status_label.pack(pady=5)
        
        self.value_label = tk.Label(root, text="sv_cheats value: Unknown", font=("Arial", 10))
        self.value_label.pack(pady=5)
        
        self.flags_label = tk.Label(root, text="Flags: Unknown", font=("Arial", 10))
        self.flags_label.pack(pady=5)
        
        # Buttons frame
        self.button_frame = tk.Frame(root)
        self.button_frame.pack(pady=10)
        
        self.toggle_button = tk.Button(self.button_frame, text="Toggle Bypass", command=self.toggle_bypass, width=15)
        self.toggle_button.grid(row=0, column=0, padx=5)
        
        self.refresh_button = tk.Button(self.button_frame, text="Refresh Status", command=self.refresh_status, width=15)
        self.refresh_button.grid(row=0, column=1, padx=5)
        
        # Advanced options frame
        self.advanced_frame = tk.LabelFrame(root, text="Advanced Options")
        self.advanced_frame.pack(pady=10, padx=10, fill="x")
        
        self.set_value_button = tk.Button(self.advanced_frame, text="Set Custom Value", command=self.set_custom_value)
        self.set_value_button.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.dump_info_button = tk.Button(self.advanced_frame, text="Dump ConVar Info", command=self.dump_convar_info)
        self.dump_info_button.pack(side=tk.RIGHT, padx=5, pady=5)
        
        # Info label
        self.info_label = tk.Label(root, text="Press INSERT key to toggle bypass", font=("Arial", 10, "italic"))
        self.info_label.pack(pady=10)
        
        # Set up cleanup on window close
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)
        
        # Update status periodically
        self.update_status()
    
    def toggle_bypass(self):
        toggle_sv_cheats_bypass()
        self.update_status()
    
    def refresh_status(self):
        self.update_status(force=True)
    
    def set_custom_value(self):
        if not sv_cheats_address:
            messagebox.showerror("Error", "sv_cheats ConVar not found!")
            return
            
        try:
            value = simpledialog.askinteger("Set sv_cheats Value", "Enter value for sv_cheats:", 
                                           minvalue=0, maxvalue=1000)
            if value is not None:
                logging.info(f"Setting custom sv_cheats value: {value}")
                pm.write_int(sv_cheats_address + CONVAR_VALUE_OFFSET, value)
                pm.write_float(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET, float(value))
                self.update_status(force=True)
        except Exception as e:
            logging.error(f"Error setting custom value: {str(e)}")
            messagebox.showerror("Error", f"Failed to set value: {str(e)}")
    
    def dump_convar_info(self):
        if not sv_cheats_address:
            messagebox.showerror("Error", "sv_cheats ConVar not found!")
            return
            
        try:
            # Read ConVar structure details
            flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
            value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
            float_value = pm.read_float(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET)
            
            # Try to read string value and name
            try:
                string_ptr = pm.read_int(sv_cheats_address + CONVAR_STRING_OFFSET)
                string_value = pm.read_string(string_ptr, 32)
            except:
                string_value = "Unable to read"
                
            try:
                name_ptr = sv_cheats_address + CONVAR_NAME_OFFSET
                name = pm.read_string(name_ptr, 32)
            except:
                name = "sv_cheats"
            
            # Format the flags as binary for better understanding
            flags_binary = format(flags, '032b')
            flags_formatted = ' '.join(flags_binary[i:i+4] for i in range(0, len(flags_binary), 4))
            
            info = (
                f"ConVar: {name}\n"
                f"Address: 0x{sv_cheats_address:X}\n"
                f"Int Value: {value}\n"
                f"Float Value: {float_value}\n"
                f"String Value: {string_value}\n"
                f"Flags (Hex): 0x{flags:X}\n"
                f"Flags (Binary): {flags_formatted}\n\n"
                f"Flag Meanings:\n"
                f"FCVAR_UNREGISTERED (1): {bool(flags & FCVAR_UNREGISTERED)}\n"
                f"FCVAR_DEVELOPMENTONLY (2): {bool(flags & FCVAR_DEVELOPMENTONLY)}\n"
                f"FCVAR_GAMEDLL (4): {bool(flags & FCVAR_GAMEDLL)}\n"
                f"FCVAR_CLIENTDLL (8): {bool(flags & FCVAR_CLIENTDLL)}\n"
                f"FCVAR_CHEAT (16): {bool(flags & FCVAR_CHEAT)}\n"
                f"FCVAR_PROTECTED (32): {bool(flags & FCVAR_PROTECTED)}\n"
                f"FCVAR_SPONLY (64): {bool(flags & FCVAR_SPONLY)}\n"
                f"FCVAR_ARCHIVE (128): {bool(flags & FCVAR_ARCHIVE)}\n"
                f"FCVAR_REPLICATED (256): {bool(flags & FCVAR_REPLICATED)}"
            )
            
            # Log the info
            logging.info(f"ConVar Dump:\n{info}")
            
            # Show in a message box
            messagebox.showinfo("ConVar Information", info)
        except Exception as e:
            logging.error(f"Error dumping ConVar info: {str(e)}")
            messagebox.showerror("Error", f"Failed to dump ConVar info: {str(e)}")
    
    def update_status(self, force=False):
        try:
            if sv_cheats_address:
                # Update game process info
                if pm and pm.process_handle:
                    process = psutil.Process(pm.process_id)
                    self.game_label.config(text=f"Game: {process.name()} (PID: {pm.process_id})")
                
                # Update sv_cheats value and flags
                value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
                flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
                
                self.value_label.config(text=f"sv_cheats value: {value}")
                self.flags_label.config(text=f"Flags: 0x{flags:X}")
                
                if bypass_active:
                    self.status_label.config(text="Status: BYPASS ACTIVE", fg="green")
                else:
                    self.status_label.config(text="Status: Inactive", fg="black")
            else:
                self.status_label.config(text="Status: ConVar Not Found", fg="red")
        except Exception as e:
            if force:
                logging.error(f"Error updating status: {str(e)}")
                self.status_label.config(text="Status: Error", fg="red")
        
        # Schedule the next update
        self.root.after(1000, self.update_status)
    
    def on_close(self):
        cleanup()
        self.root.destroy()

def main():
    try:
        # Initialize the application
        if not initialize():
            return
        
        # Create the main window
        root = tk.Tk()
        app = SvCheatsApp(root)
        
        # Start the message pump
        root.mainloop()
    except Exception as e:
        logging.error(f"Exception in main: {str(e)}")
        messagebox.showerror("Error", f"An error occurred: {str(e)}")

if __name__ == "__main__":
    main()

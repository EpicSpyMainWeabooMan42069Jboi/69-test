import os
import sys
import time
import random
import string
import ctypes
import logging
import psutil
import pymem
import pymem.process
from ctypes import wintypes
from datetime import datetime
import tkinter as tk
from tkinter import messagebox, simpledialog

# Set up logging
logging.basicConfig(
    filename='sv_cheats_bypass_log.txt',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filemode='w'
)

# Constants for Windows API
WH_KEYBOARD_LL = 13
WM_KEYDOWN = 0x0100
VK_INSERT = 0x2D

# Memory protection constants
PAGE_EXECUTE_READWRITE = 0x40
PAGE_READWRITE = 0x04

# Global variables
bypass_active = False
keyboard_hook = None
keyboard_callback = None  # keep a reference to the callback to avoid GC
pm = None  # Pymem instance
sv_cheats_address = None
original_flags = 0
original_value = 0

# ConVar offsets - these would need to be updated for specific games
CONVAR_NAME_OFFSET = 0x0C
CONVAR_FLAGS_OFFSET = 0x14
CONVAR_VALUE_OFFSET = 0x30
CONVAR_FLOAT_VALUE_OFFSET = 0x2C
CONVAR_STRING_OFFSET = 0x24

# Flag definitions
FCVAR_UNREGISTERED = (1 << 0)
FCVAR_DEVELOPMENTONLY = (1 << 1)
FCVAR_GAMEDLL = (1 << 2)
FCVAR_CLIENTDLL = (1 << 3)
FCVAR_CHEAT = (1 << 4)
FCVAR_PROTECTED = (1 << 5)
FCVAR_SPONLY = (1 << 6)
FCVAR_ARCHIVE = (1 << 7)
FCVAR_REPLICATED = (1 << 8)

def safe_write_memory(address, value, data_type):
    """Safely write to memory with error handling"""
    try:
        old_protect = ctypes.c_ulong()
        size = 4 if data_type in ["int", "float"] else len(str(value))
        
        # Change memory protection
        ctypes.windll.kernel32.VirtualProtectEx(
            pm.process_handle,
            ctypes.c_void_p(address),
            size,
            PAGE_EXECUTE_READWRITE,
            ctypes.byref(old_protect)
        )
        
        # Write the value
        if data_type == "int":
            pm.write_int(address, value)
        elif data_type == "float":
            pm.write_float(address, value)
        else:
            pm.write_bytes(address, value, len(value))
        
        # Restore original protection
        ctypes.windll.kernel32.VirtualProtectEx(
            pm.process_handle,
            ctypes.c_void_p(address),
            size,
            old_protect.value,
            ctypes.byref(old_protect)
        )
        
        return True
    except Exception as e:
        logging.error(f"Failed to write memory at 0x{address:X}: {str(e)}")
        return False

def find_convar_improved(name):
    """Improved ConVar finding with better validation"""
    try:
        logging.info(f"Searching for ConVar: {name}")
        
        # Get all memory regions
        for module in pm.list_modules():
            try:
                module_name = getattr(module, "name", "").lower()
                if not any(x in module_name for x in ["engine", "server", "client"]):
                    continue
                
                logging.info(f"Scanning module: {module_name}")
                
                # Scan memory in chunks
                base_addr = module.lpBaseOfDll
                max_addr = base_addr + module.SizeOfImage
                chunk_size = 0x1000  # 4KB chunks
                
                for addr in range(base_addr, max_addr, chunk_size):
                    try:
                        # Read chunk
                        data = pm.read_bytes(addr, min(chunk_size, max_addr - addr))
                        
                        # Look for the ConVar name
                        name_bytes = name.encode('ascii') + b'\x00'
                        offset = data.find(name_bytes)
                        
                        if offset != -1:
                            potential_addr = addr + offset - CONVAR_NAME_OFFSET
                            validated_addr = validate_convar_structure(potential_addr, name)
                            if validated_addr:
                                return validated_addr
                    except Exception:
                        continue
            except Exception as e:
                logging.error(f"Error scanning module {module_name}: {str(e)}")
                continue
        
        return None
    except Exception as e:
        logging.error(f"Error in find_convar_improved: {str(e)}")
        return None

def validate_convar_structure(base_addr, expected_name):
    """Validate that the address points to a valid ConVar structure"""
    try:
        # Basic address validation
        if base_addr < 0x10000 or base_addr > 0x7FFFFFFF:
            return None
        
        # Try to read and validate the structure
        for attempt in range(3):  # Try a few times
            try:
                # Skip obviously invalid addresses
                if base_addr & 0xFFFF > 0x10000:
                    continue
                
                try:
                    read_name = pm.read_string(base_addr + CONVAR_NAME_OFFSET, len(expected_name) + 1)
                    if read_name and read_name.lower() == expected_name.lower():
                        logging.info(f"Validated ConVar {expected_name} at 0x{base_addr:X}")
                        return base_addr
                except Exception:
                    pass
            except Exception:
                continue
        
        return None
    except Exception as e:
        logging.error(f"Error validating ConVar structure: {str(e)}")
        return None

def elevate_process_privileges():
    """Attempt to get debug privileges"""
    try:
        import ctypes.wintypes as wt
        
        token = wt.HANDLE()
        ctypes.windll.advapi32.OpenProcessToken(
            ctypes.windll.kernel32.GetCurrentProcess(),
            0x0020 | 0x0008,  # TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY
            ctypes.byref(token)
        )
        
        class LUID(ctypes.Structure):
            _fields_ = [("LowPart", wintypes.DWORD),
                       ("HighPart", wintypes.LONG)]
        
        class LUID_AND_ATTRIBUTES(ctypes.Structure):
            _fields_ = [("Luid", LUID),
                       ("Attributes", wintypes.DWORD)]
        
        class TOKEN_PRIVILEGES(ctypes.Structure):
            _fields_ = [("PrivilegeCount", wintypes.DWORD),
                       ("Privileges", LUID_AND_ATTRIBUTES * 1)]
        
        luid = LUID()
        if not ctypes.windll.advapi32.LookupPrivilegeValueW(None, "SeDebugPrivilege", ctypes.byref(luid)):
            return False
        
        tp = TOKEN_PRIVILEGES()
        tp.PrivilegeCount = 1
        tp.Privileges[0].Luid = luid
        tp.Privileges[0].Attributes = 0x00000002  # SE_PRIVILEGE_ENABLED
        
        ctypes.windll.advapi32.AdjustTokenPrivileges(token, False, ctypes.byref(tp), 0, None, None)
        return True
    except Exception as e:
        logging.warning(f"Could not elevate privileges: {str(e)}")
        return False

def random_string(length):
    """Generate a random string of fixed length"""
    letters = string.ascii_letters
    return ''.join(random.choice(letters) for _ in range(length))

def find_game_process(game_names):
    """Find the game process by name"""
    try:
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                pname = (proc.info.get('name') or '').lower()
                for game_name in game_names:
                    if game_name.lower() in pname:
                        logging.info(f"Found game process: {proc.info.get('name')} (PID: {proc.info.get('pid')})")
                        return proc.info.get('pid')
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        return None
    except Exception as e:
        logging.error(f"Error finding game process: {str(e)}")
        return None

def find_cvar_interface():
    """Find the ICvar interface in the game memory"""
    try:
        logging.info("Looking for ICvar interface...")
        
        vstdlib = None
        for module in pm.list_modules():
            if getattr(module, "name", "").lower() == "vstdlib.dll":
                vstdlib = module
                break
        
        if not vstdlib:
            logging.error("vstdlib.dll not found")
            return None
        
        logging.info(f"Found vstdlib.dll at 0x{vstdlib.lpBaseOfDll:X}")
        
        # A real implementation would parse CreateInterface exports; we keep a placeholder.
        _ = pm.read_bytes(vstdlib.lpBaseOfDll, 0x100)  # small read to validate access
        
        logging.info("Successfully found ICvar interface (simulated)")
        return True
    except Exception as e:
        logging.error(f"Error finding ICvar interface: {str(e)}")
        return None

def enable_sv_cheats_bypass():
    global bypass_active, original_flags, original_value
    
    try:
        if not sv_cheats_address:
            messagebox.showerror("Error", "sv_cheats ConVar not found!")
            return
        
        logging.info("Attempting to enable sv_cheats bypass...")
        
        try:
            original_flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
            original_value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
        except Exception as e:
            logging.error(f"Failed to read original values: {str(e)}")
            return
        
        logging.info(f"Original sv_cheats flags: 0x{original_flags:X}, value: {original_value}")
        
        new_flags = original_flags
        new_flags &= ~FCVAR_CHEAT
        new_flags &= ~FCVAR_REPLICATED
        new_flags &= ~FCVAR_PROTECTED
        new_flags &= ~FCVAR_SPONLY
        
        if not safe_write_memory(sv_cheats_address + CONVAR_FLAGS_OFFSET, new_flags, "int"):
            messagebox.showerror("Error", "Failed to modify ConVar flags!")
            return
        
        if not safe_write_memory(sv_cheats_address + CONVAR_VALUE_OFFSET, 1, "int"):
            messagebox.showerror("Error", "Failed to modify ConVar value!")
            return
        
        if not safe_write_memory(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET, 1.0, "float"):
            logging.warning("Failed to modify float value, but continuing...")
        
        current_flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
        current_value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
        
        logging.info(f"After bypass: flags=0x{current_flags:X}, value={current_value}")
        
        bypass_active = True
        messagebox.showinfo("Success", "sv_cheats bypass ENABLED")
    except Exception as e:
        logging.error(f"Exception in enable_sv_cheats_bypass: {str(e)}")
        messagebox.showerror("Error", f"Failed to enable bypass: {str(e)}")

def disable_sv_cheats_bypass():
    global bypass_active
    
    try:
        if not sv_cheats_address:
            return
        
        logging.info("Attempting to disable sv_cheats bypass...")
        
        # Restore original flags and value
        pm.write_int(sv_cheats_address + CONVAR_FLAGS_OFFSET, original_flags)
        pm.write_int(sv_cheats_address + CONVAR_VALUE_OFFSET, original_value)
        pm.write_float(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET, float(original_value))
        
        # Verify the changes
        current_flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
        current_value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
        
        logging.info(f"After restore: sv_cheats flags = 0x{current_flags:X}, value = {current_value}")
        
        bypass_active = False
        messagebox.showinfo("Status", "sv_cheats bypass DISABLED")
    except Exception as e:
        logging.error(f"Exception in disable_sv_cheats_bypass: {str(e)}")

def toggle_sv_cheats_bypass():
    try:
        logging.info("Toggle function called")
        if not bypass_active:
            enable_sv_cheats_bypass()
        else:
            disable_sv_cheats_bypass()
    except Exception as e:
        logging.error(f"Exception in toggle_sv_cheats_bypass: {str(e)}")

# minimal KBDLLHOOKSTRUCT to read vkCode
class KBDLLHOOKSTRUCT(ctypes.Structure):
    _fields_ = [
        ('vkCode', wintypes.DWORD),
        ('scanCode', wintypes.DWORD),
        ('flags', wintypes.DWORD),
        ('time', wintypes.DWORD),
        ('dwExtraInfo', ctypes.c_void_p),
    ]

# Keyboard hook callback function
@ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_int, wintypes.WPARAM, wintypes.LPARAM)
def low_level_keyboard_handler(nCode, wParam, lParam):
    try:
        if nCode >= 0 and wParam == WM_KEYDOWN:
            kb_struct = ctypes.cast(lParam, ctypes.POINTER(KBDLLHOOKSTRUCT)).contents
            vk_code = kb_struct.vkCode
            
            # Check for INSERT key
            if vk_code == VK_INSERT:
                logging.info("INSERT key detected!")
                toggle_sv_cheats_bypass()
                return 1  # Prevent other hooks from processing this key
    except Exception as e:
        logging.error(f"Exception in keyboard handler: {str(e)}")
    
    # Call the next hook
    return ctypes.windll.user32.CallNextHookEx(keyboard_hook, nCode, wParam, lParam)

def set_keyboard_hook():
    global keyboard_hook, keyboard_callback
    
    try:
        logging.info("Setting up keyboard hook")
        
        # Keep a reference to callback to avoid it being garbage-collected
        keyboard_callback = low_level_keyboard_handler
        
        # Set the hook
        keyboard_hook = ctypes.windll.user32.SetWindowsHookExW(
            WH_KEYBOARD_LL,
            keyboard_callback,
            ctypes.windll.kernel32.GetModuleHandleW(None),
            0
        )
        
        if not keyboard_hook:
            logging.error("Failed to set keyboard hook!")
            messagebox.showerror("Error", "Failed to set keyboard hook!")
            return False
        
        logging.info("Keyboard hook set up successfully")
        return True
    except Exception as e:
        logging.error(f"Exception in set_keyboard_hook: {str(e)}")
        return False

def cleanup():
    global keyboard_hook, pm
    
    try:
        logging.info("Cleaning up resources")
        
        # Disable the bypass if active
        if bypass_active:
            disable_sv_cheats_bypass()
        
        # Unhook keyboard hook
        if keyboard_hook:
            ctypes.windll.user32.UnhookWindowsHookEx(keyboard_hook)
            keyboard_hook = None
        
        # Close Pymem instance
        if pm:
            try:
                pm.close_process()
            except Exception:
                pass
        
        logging.info("Cleanup complete")
    except Exception as e:
        logging.error(f"Exception in cleanup: {str(e)}")

def initialize():
    global pm, sv_cheats_address
    
    try:
        # Try to elevate privileges first
        elevate_process_privileges()
        
        # Clear log file
        with open('sv_cheats_bypass_log.txt', 'w', encoding='utf-8') as f:
            f.write("Initializing sv_cheats bypass plugin...\n")
        
        # Set random seed
        random.seed(time.time())
        
        # Find game process
        game_names = ["hl2.exe", "csgo.exe", "portal2.exe", "left4dead2.exe", "tf_win64.exe"]
        game_pid = find_game_process(game_names)
        
        if not game_pid:
            logging.error("Game process not found!")
            messagebox.showerror("Error", "Game process not found! Make sure the game is running.")
            return False
        
        # Open the process
        try:
            pm = pymem.Pymem(game_pid)
            logging.info(f"Successfully opened game process (PID: {game_pid})")
        except Exception as e:
            logging.error(f"Failed to open game process: {str(e)}")
            messagebox.showerror("Error", f"Failed to open game process: {str(e)}")
            return False
        
        # Find ICvar interface
        if not find_cvar_interface():
            logging.error("Failed to find ICvar interface!")
            messagebox.showerror("Error", "Failed to find ICvar interface!")
            return False
        
        # Find sv_cheats ConVar
        sv_cheats_address = find_convar("sv_cheats")
        if not sv_cheats_address:
            logging.error("Failed to find sv_cheats ConVar!")
            messagebox.showerror("Error", "Failed to find sv_cheats ConVar!")
            return False
        
        # Set up keyboard hook
        if not set_keyboard_hook():
            return False
        
        messagebox.showinfo("Plugin Loaded", "sv_cheats Bypass Plugin Loaded!\nPress INSERT key to toggle bypass.")
        return True
    except Exception as e:
        logging.error(f"Exception in initialize: {str(e)}")
        messagebox.showerror("Error", f"Initialization error: {str(e)}")
        return False

# Alias to fix "find_convar is not defined"
def find_convar(name: str):
    return find_convar_improved(name)

class SvCheatsApp:
    def __init__(self, root):
        self.root = root
        self.root.title("sv_cheats Bypass Tool")
        self.root.geometry("400x300")
        self.root.resizable(False, False)
        
        # Create UI elements
        self.label = tk.Label(root, text="sv_cheats Bypass Tool", font=("Arial", 14, "bold"))
        self.label.pack(pady=10)
        
        self.game_label = tk.Label(root, text="Game: Not connected", font=("Arial", 10))
        self.game_label.pack(pady=5)
        
        self.status_label = tk.Label(root, text="Status: Inactive", font=("Arial", 12))
        self.status_label.pack(pady=5)
        
        self.value_label = tk.Label(root, text="sv_cheats value: Unknown", font=("Arial", 10))
        self.value_label.pack(pady=5)
        
        self.flags_label = tk.Label(root, text="Flags: Unknown", font=("Arial", 10))
        self.flags_label.pack(pady=5)
        
        # Buttons frame
        self.button_frame = tk.Frame(root)
        self.button_frame.pack(pady=10)
        
        self.toggle_button = tk.Button(self.button_frame, text="Toggle Bypass", command=self.toggle_bypass, width=15)
        self.toggle_button.grid(row=0, column=0, padx=5)
        
        self.refresh_button = tk.Button(self.button_frame, text="Refresh Status", command=self.refresh_status, width=15)
        self.refresh_button.grid(row=0, column=1, padx=5)
        
        # Advanced options frame
        self.advanced_frame = tk.LabelFrame(root, text="Advanced Options")
        self.advanced_frame.pack(pady=10, padx=10, fill="x")
        
        self.set_value_button = tk.Button(self.advanced_frame, text="Set Custom Value", command=self.set_custom_value)
        self.set_value_button.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.dump_info_button = tk.Button(self.advanced_frame, text="Dump ConVar Info", command=self.dump_convar_info)
        self.dump_info_button.pack(side=tk.RIGHT, padx=5, pady=5)
        
        # Info label
        self.info_label = tk.Label(root, text="Press INSERT key to toggle bypass", font=("Arial", 10, "italic"))
        self.info_label.pack(pady=10)
        
        # Set up cleanup on window close
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)
        
        # Update status periodically
        self.update_status()
    
    def toggle_bypass(self):
        toggle_sv_cheats_bypass()
        self.update_status()
    
    def refresh_status(self):
        self.update_status(force=True)
    
    def set_custom_value(self):
        if not sv_cheats_address:
            messagebox.showerror("Error", "sv_cheats ConVar not found!")
            return
        
        try:
            value = simpledialog.askinteger("Set sv_cheats Value", "Enter value for sv_cheats:",
                                          minvalue=0, maxvalue=1000)
            if value is not None:
                logging.info(f"Setting custom sv_cheats value: {value}")
                pm.write_int(sv_cheats_address + CONVAR_VALUE_OFFSET, value)
                pm.write_float(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET, float(value))
                self.update_status(force=True)
        except Exception as e:
            logging.error(f"Error setting custom value: {str(e)}")
            messagebox.showerror("Error", f"Failed to set value: {str(e)}")
    
    def dump_convar_info(self):
        if not sv_cheats_address:
            messagebox.showerror("Error", "sv_cheats ConVar not found!")
            return
        
        try:
            # Read ConVar structure details
            flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
            value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
            float_value = pm.read_float(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET)
            
            # Try to read string value and name
            try:
                string_ptr = pm.read_int(sv_cheats_address + CONVAR_STRING_OFFSET)
                string_value = pm.read_string(string_ptr, 32)
            except Exception:
                string_value = "Unable to read"
            
            try:
                name_ptr = sv_cheats_address + CONVAR_NAME_OFFSET
                name = pm.read_string(name_ptr, 32)
            except Exception:
                name = "sv_cheats"
            
            # Format the flags as binary for better understanding
            flags_binary = format(flags, '032b')
            flags_formatted = ' '.join(flags_binary[i:i+4] for i in range(0, len(flags_binary), 4))
            
            info = (
                f"ConVar: {name}\n"
                f"Address: 0x{sv_cheats_address:X}\n"
                f"Int Value: {value}\n"
                f"Float Value: {float_value}\n"
                f"String Value: {string_value}\n"
                f"Flags (Hex): 0x{flags:X}\n"
                f"Flags (Binary): {flags_formatted}\n\n"
                f"Flag Meanings:\n"
                f"FCVAR_UNREGISTERED (1): {bool(flags & FCVAR_UNREGISTERED)}\n"
                f"FCVAR_DEVELOPMENTONLY (2): {bool(flags & FCVAR_DEVELOPMENTONLY)}\n"
                f"FCVAR_GAMEDLL (4): {bool(flags & FCVAR_GAMEDLL)}\n"
                f"FCVAR_CLIENTDLL (8): {bool(flags & FCVAR_CLIENTDLL)}\n"
                f"FCVAR_CHEAT (16): {bool(flags & FCVAR_CHEAT)}\n"
                f"FCVAR_PROTECTED (32): {bool(flags & FCVAR_PROTECTED)}\n"
                f"FCVAR_SPONLY (64): {bool(flags & FCVAR_SPONLY)}\n"
                f"FCVAR_ARCHIVE (128): {bool(flags & FCVAR_ARCHIVE)}\n"
                f"FCVAR_REPLICATED (256): {bool(flags & FCVAR_REPLICATED)}"
            )
            
            # Log the info
            logging.info(f"ConVar Dump:\n{info}")
            
            # Show in a message box
            messagebox.showinfo("ConVar Information", info)
        except Exception as e:
            logging.error(f"Error dumping ConVar info: {str(e)}")
            messagebox.showerror("Error", f"Failed to dump ConVar info: {str(e)}")
    
    def update_status(self, force=False):
        try:
            if sv_cheats_address:
                # Update game process info
                if pm and pm.process_handle:
                    process = psutil.Process(pm.process_id)
                    self.game_label.config(text=f"Game: {process.name()} (PID: {pm.process_id})")
                
                # Update sv_cheats value and flags
                value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
                flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
                
                self.value_label.config(text=f"sv_cheats value: {value}")
                self.flags_label.config(text=f"Flags: 0x{flags:X}")
                
                if bypass_active:
                    self.status_label.config(text="Status: BYPASS ACTIVE", fg="green")
                else:
                    self.status_label.config(text="Status: Inactive", fg="black")
            else:
                self.status_label.config(text="Status: ConVar Not Found", fg="red")
        except Exception as e:
            if force:
                logging.error(f"Error updating status: {str(e)}")
            self.status_label.config(text="Status: Error", fg="red")
        
        # Schedule the next update
        self.root.after(1000, self.update_status)
    
    def on_close(self):
        cleanup()
        self.root.destroy()

def main():
    try:
        # Initialize the application
        if not initialize():
            return
        
        # Create the main window
        root = tk.Tk()
        app = SvCheatsApp(root)
        
        # Start the message pump
        root.mainloop()
    except Exception as e:
        logging.error(f"Exception in main: {str(e)}")
        messagebox.showerror("Error", f"An error occurred: {str(e)}")

if __name__ == "__main__":
    main()

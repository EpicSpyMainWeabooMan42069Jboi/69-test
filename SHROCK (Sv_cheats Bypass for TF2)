Now then, this is a little thought I had for a while now, that’s been swirling around and I could get an answer for it… If I went to TOR one more time and took my time after searching and digging hypothetically, came across a site for Hacking, or a form to do discussions like a Q/A, I would give out a topic on the house, as a little deal.

Basically, I wanna know if it’s possible to share the code of SHROCK (Sv_cheats Bypass for TF2)to them to see if *they* could possibly lend a hand out, for a broken heart to mend, and in return; I ask for personal questions/answers as to how it functions and if it would actually work, and knowledge that I haven't gained yet.

Also, I’m not 2 years old, and If they try to fuck with me by either ddos/ sending a trojin/RAT, then I will cut ties with them completely, because I WILL find out if they did that or not, which is stupid, becuase why would you do that to a pal like me?  


import os
import sys
import time
import random
import string
import ctypes
import logging
import psutil
import pymem
import pymem.process
from ctypes import wintypes
from datetime import datetime
import tkinter as tk
from tkinter import messagebox, simpledialog

# Set up logging
logging.basicConfig(
    filename='sv_cheats_bypass_log.txt',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filemode='w'
)

# Constants for Windows API
WH_KEYBOARD_LL = 13
WM_KEYDOWN = 0x0100
VK_INSERT = 0x2D

# Global variables
bypass_active = False
keyboard_hook = None
pm = None  # Pymem instance
game_process = None
sv_cheats_address = None
original_flags = 0
original_value = 0

# ConVar offsets - these would need to be updated for specific games
CONVAR_NAME_OFFSET = 0x0C
CONVAR_FLAGS_OFFSET = 0x14
CONVAR_VALUE_OFFSET = 0x30
CONVAR_FLOAT_VALUE_OFFSET = 0x2C
CONVAR_STRING_OFFSET = 0x24

# Flag definitions
FCVAR_UNREGISTERED = (1 << 0)
FCVAR_DEVELOPMENTONLY = (1 << 1)
FCVAR_GAMEDLL = (1 << 2)
FCVAR_CLIENTDLL = (1 << 3)
FCVAR_CHEAT = (1 << 4)
FCVAR_PROTECTED = (1 << 5)
FCVAR_SPONLY = (1 << 6)
FCVAR_ARCHIVE = (1 << 7)
FCVAR_REPLICATED = (1 << 8)

def random_string(length):
    """Generate a random string of fixed length"""
    letters = string.ascii_letters
    return ''.join(random.choice(letters) for _ in range(length))

def find_game_process(game_names):
    """Find the game process by name"""
    try:
        for proc in psutil.process_iter(['pid', 'name']):
            for game_name in game_names:
                if game_name.lower() in proc.info['name'].lower():
                    logging.info(f"Found game process: {proc.info['name']} (PID: {proc.info['pid']})")
                    return proc.info['pid']
        return None
    except Exception as e:
        logging.error(f"Error finding game process: {str(e)}")
        return None

def find_cvar_interface():
    """Find the ICvar interface in the game memory"""
    try:
        logging.info("Looking for ICvar interface...")
        
        # Try to find vstdlib.dll module
        vstdlib = None
        for module in pm.list_modules():
            if module.name.lower() == "vstdlib.dll":
                vstdlib = module
                break
        
        if not vstdlib:
            logging.error("vstdlib.dll not found")
            return None
            
        logging.info(f"Found vstdlib.dll at 0x{vstdlib.lpBaseOfDll:X}")
        
        # This part is highly game-specific and would require pattern scanning
        # For demonstration, we'll use a simplified approach
        
        # Try to find CreateInterface function
        create_interface = pm.read_bytes(vstdlib.lpBaseOfDll, 0x1000)
        # In a real implementation, you would scan for the CreateInterface pattern
        
        # For demonstration, we'll assume we found the ICvar interface
        # In reality, this would require more complex pattern scanning and pointer following
        logging.info("Successfully found ICvar interface (simulated)")
        return True
    except Exception as e:
        logging.error(f"Error finding ICvar interface: {str(e)}")
        return None

def find_convar(name):
    """Find a ConVar by name in the game memory"""
    try:
        logging.info(f"Looking for ConVar: {name}")
        
        # In a real implementation, this would involve:
        # 1. Finding the ConVar list head pointer
        # 2. Traversing the linked list of ConVars
        # 3. Checking each ConVar's name against the target name
        
        # For demonstration, we'll use a simplified approach with pattern scanning
        
        # Example pattern for sv_cheats (this would be game-specific)
        pattern = b"sv_cheats\x00"
        
        # Search for the pattern in the game's memory
        matches = pymem.pattern.pattern_scan_all(pm.process_handle, pattern, return_multiple=True)
        
        if not matches:
            logging.error(f"Could not find {name} ConVar")
            return None
            
        # For each match, check if it's actually a ConVar
        for match in matches:
            try:
                # Check if this is a valid ConVar by reading its structure
                # This is a simplified check and would need to be more robust in practice
                possible_convar_addr = match - CONVAR_NAME_OFFSET
                flags = pm.read_int(possible_convar_addr + CONVAR_FLAGS_OFFSET)
                
                # If it has reasonable flags, it might be our ConVar
                if 0 <= flags <= 0xFFFF:
                    value = pm.read_int(possible_convar_addr + CONVAR_VALUE_OFFSET)
                    logging.info(f"Found potential {name} at 0x{possible_convar_addr:X}, value={value}, flags=0x{flags:X}")
                    return possible_convar_addr
            except Exception:
                continue
                
        logging.error(f"Could not find valid {name} ConVar")
        return None
    except Exception as e:
        logging.error(f"Error finding ConVar {name}: {str(e)}")
        return None

def enable_sv_cheats_bypass():
    global bypass_active, original_flags, original_value
    
    try:
        if not sv_cheats_address:
            messagebox.showerror("Error", "sv_cheats ConVar not found!")
            return
            
        logging.info("Attempting to enable sv_cheats bypass...")
        
        # Save original values
        original_flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
        original_value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
        
        logging.info(f"Original sv_cheats flags: 0x{original_flags:X}, value: {original_value}")
        
        # Remove protection flags
        new_flags = original_flags
        new_flags &= ~FCVAR_CHEAT
        new_flags &= ~FCVAR_REPLICATED
        new_flags &= ~FCVAR_PROTECTED
        new_flags &= ~FCVAR_SPONLY
        
        # Write the new flags to memory
        pm.write_int(sv_cheats_address + CONVAR_FLAGS_OFFSET, new_flags)
        
        # Set sv_cheats to 1
        pm.write_int(sv_cheats_address + CONVAR_VALUE_OFFSET, 1)
        pm.write_float(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET, 1.0)
        
        # Verify the changes
        current_flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
        current_value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
        
        logging.info(f"After bypass: sv_cheats flags = 0x{current_flags:X}, value = {current_value}")
        
        bypass_active = True
        messagebox.showinfo("Success", "sv_cheats bypass ENABLED")
    except Exception as e:
        logging.error(f"Exception in enable_sv_cheats_bypass: {str(e)}")
        messagebox.showerror("Error", f"Failed to enable bypass: {str(e)}")

def disable_sv_cheats_bypass():
    global bypass_active
    
    try:
        if not sv_cheats_address:
            return
            
        logging.info("Attempting to disable sv_cheats bypass...")
        
        # Restore original flags and value
        pm.write_int(sv_cheats_address + CONVAR_FLAGS_OFFSET, original_flags)
        pm.write_int(sv_cheats_address + CONVAR_VALUE_OFFSET, original_value)
        pm.write_float(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET, float(original_value))
        
        # Verify the changes
        current_flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
        current_value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
        
        logging.info(f"After restore: sv_cheats flags = 0x{current_flags:X}, value = {current_value}")
        
        bypass_active = False
        messagebox.showinfo("Status", "sv_cheats bypass DISABLED")
    except Exception as e:
        logging.error(f"Exception in disable_sv_cheats_bypass: {str(e)}")

def toggle_sv_cheats_bypass():
    try:
        logging.info("Toggle function called")
        if not bypass_active:
            enable_sv_cheats_bypass()
        else:
            disable_sv_cheats_bypass()
    except Exception as e:
        logging.error(f"Exception in toggle_sv_cheats_bypass: {str(e)}")

# Keyboard hook callback function
def low_level_keyboard_handler(nCode, wParam, lParam):
    try:
        if nCode >= 0 and wParam == WM_KEYDOWN:
            kb_struct = ctypes.cast(lParam, ctypes.POINTER(ctypes.c_ulong))
            vk_code = kb_struct[0]
            
            # Check for INSERT key
            if vk_code == VK_INSERT:
                logging.info("INSERT key detected!")
                toggle_sv_cheats_bypass()
                return 1  # Prevent other hooks from processing this key
    except Exception as e:
        logging.error(f"Exception in keyboard handler: {str(e)}")
    
    # Call the next hook
    return ctypes.windll.user32.CallNextHookEx(keyboard_hook, nCode, wParam, lParam)

def set_keyboard_hook():
    global keyboard_hook
    
    try:
        logging.info("Setting up keyboard hook")
        
        # Define the callback function type
        CMPFUNC = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.POINTER(ctypes.c_void_p))
        pointer = CMPFUNC(low_level_keyboard_handler)
        
        # Set the hook
        keyboard_hook = ctypes.windll.user32.SetWindowsHookExA(
            WH_KEYBOARD_LL, 
            pointer, 
            ctypes.windll.kernel32.GetModuleHandleA(None), 
            0
        )
        
        if not keyboard_hook:
            logging.error("Failed to set keyboard hook!")
            messagebox.showerror("Error", "Failed to set keyboard hook!")
            return False
            
        logging.info("Keyboard hook set up successfully")
        return True
    except Exception as e:
        logging.error(f"Exception in set_keyboard_hook: {str(e)}")
        return False

def cleanup():
    global keyboard_hook, pm
    
    try:
        logging.info("Cleaning up resources")
        
        # Disable the bypass if active
        if bypass_active:
            disable_sv_cheats_bypass()
        
        # Unhook keyboard hook
        if keyboard_hook:
            ctypes.windll.user32.UnhookWindowsHookEx(keyboard_hook)
            keyboard_hook = None
        
        # Close Pymem instance
        if pm:
            pm.close_process()
            
        logging.info("Cleanup complete")
    except Exception as e:
        logging.error(f"Exception in cleanup: {str(e)}")

def initialize():
    global pm, sv_cheats_address
    
    try:
        # Clear log file
        with open('sv_cheats_bypass_log.txt', 'w') as f:
            f.write("Initializing sv_cheats bypass plugin...\n")
        
        # Set random seed
        random.seed(time.time())
        
        # Find game process
        game_names = ["hl2.exe", "csgo.exe", "portal2.exe", "left4dead2.exe", "tf_win64.exe"]
        game_pid = find_game_process(game_names)
        
        if not game_pid:
            logging.error("Game process not found!")
            messagebox.showerror("Error", "Game process not found! Make sure the game is running.")
            return False
        
        # Open the process
        try:
            pm = pymem.Pymem(game_pid)
            logging.info(f"Successfully opened game process (PID: {game_pid})")
        except Exception as e:
            logging.error(f"Failed to open game process: {str(e)}")
            messagebox.showerror("Error", f"Failed to open game process: {str(e)}")
            return False
        
        # Find ICvar interface
        if not find_cvar_interface():
            logging.error("Failed to find ICvar interface!")
            messagebox.showerror("Error", "Failed to find ICvar interface!")
            return False
        
        # Find sv_cheats ConVar
        sv_cheats_address = find_convar("sv_cheats")
        if not sv_cheats_address:
            logging.error("Failed to find sv_cheats ConVar!")
            messagebox.showerror("Error", "Failed to find sv_cheats ConVar!")
            return False
        
        # Set up keyboard hook
        if not set_keyboard_hook():
            return False
        
        messagebox.showinfo("Plugin Loaded", "sv_cheats Bypass Plugin Loaded!\nPress INSERT key to toggle bypass.")
        return True
    except Exception as e:
        logging.error(f"Exception in initialize: {str(e)}")
        messagebox.showerror("Error", f"Initialization error: {str(e)}")
        return False

class SvCheatsApp:
    def __init__(self, root):
        self.root = root
        self.root.title("sv_cheats Bypass Tool")
        self.root.geometry("400x300")
        self.root.resizable(False, False)
        
        # Create UI elements
        self.label = tk.Label(root, text="sv_cheats Bypass Tool", font=("Arial", 14, "bold"))
        self.label.pack(pady=10)
        
        self.game_label = tk.Label(root, text="Game: Not connected", font=("Arial", 10))
        self.game_label.pack(pady=5)
        
        self.status_label = tk.Label(root, text="Status: Inactive", font=("Arial", 12))
        self.status_label.pack(pady=5)
        
        self.value_label = tk.Label(root, text="sv_cheats value: Unknown", font=("Arial", 10))
        self.value_label.pack(pady=5)
        
        self.flags_label = tk.Label(root, text="Flags: Unknown", font=("Arial", 10))
        self.flags_label.pack(pady=5)
        
        # Buttons frame
        self.button_frame = tk.Frame(root)
        self.button_frame.pack(pady=10)
        
        self.toggle_button = tk.Button(self.button_frame, text="Toggle Bypass", command=self.toggle_bypass, width=15)
        self.toggle_button.grid(row=0, column=0, padx=5)
        
        self.refresh_button = tk.Button(self.button_frame, text="Refresh Status", command=self.refresh_status, width=15)
        self.refresh_button.grid(row=0, column=1, padx=5)
        
        # Advanced options frame
        self.advanced_frame = tk.LabelFrame(root, text="Advanced Options")
        self.advanced_frame.pack(pady=10, padx=10, fill="x")
        
        self.set_value_button = tk.Button(self.advanced_frame, text="Set Custom Value", command=self.set_custom_value)
        self.set_value_button.pack(side=tk.LEFT, padx=5, pady=5)
        
        self.dump_info_button = tk.Button(self.advanced_frame, text="Dump ConVar Info", command=self.dump_convar_info)
        self.dump_info_button.pack(side=tk.RIGHT, padx=5, pady=5)
        
        # Info label
        self.info_label = tk.Label(root, text="Press INSERT key to toggle bypass", font=("Arial", 10, "italic"))
        self.info_label.pack(pady=10)
        
        # Set up cleanup on window close
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)
        
        # Update status periodically
        self.update_status()
    
    def toggle_bypass(self):
        toggle_sv_cheats_bypass()
        self.update_status()
    
    def refresh_status(self):
        self.update_status(force=True)
    
    def set_custom_value(self):
        if not sv_cheats_address:
            messagebox.showerror("Error", "sv_cheats ConVar not found!")
            return
            
        try:
            value = simpledialog.askinteger("Set sv_cheats Value", "Enter value for sv_cheats:", 
                                           minvalue=0, maxvalue=1000)
            if value is not None:
                logging.info(f"Setting custom sv_cheats value: {value}")
                pm.write_int(sv_cheats_address + CONVAR_VALUE_OFFSET, value)
                pm.write_float(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET, float(value))
                self.update_status(force=True)
        except Exception as e:
            logging.error(f"Error setting custom value: {str(e)}")
            messagebox.showerror("Error", f"Failed to set value: {str(e)}")
    
    def dump_convar_info(self):
        if not sv_cheats_address:
            messagebox.showerror("Error", "sv_cheats ConVar not found!")
            return
            
        try:
            # Read ConVar structure details
            flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
            value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
            float_value = pm.read_float(sv_cheats_address + CONVAR_FLOAT_VALUE_OFFSET)
            
            # Try to read string value and name
            try:
                string_ptr = pm.read_int(sv_cheats_address + CONVAR_STRING_OFFSET)
                string_value = pm.read_string(string_ptr, 32)
            except:
                string_value = "Unable to read"
                
            try:
                name_ptr = sv_cheats_address + CONVAR_NAME_OFFSET
                name = pm.read_string(name_ptr, 32)
            except:
                name = "sv_cheats"
            
            # Format the flags as binary for better understanding
            flags_binary = format(flags, '032b')
            flags_formatted = ' '.join(flags_binary[i:i+4] for i in range(0, len(flags_binary), 4))
            
            info = (
                f"ConVar: {name}\n"
                f"Address: 0x{sv_cheats_address:X}\n"
                f"Int Value: {value}\n"
                f"Float Value: {float_value}\n"
                f"String Value: {string_value}\n"
                f"Flags (Hex): 0x{flags:X}\n"
                f"Flags (Binary): {flags_formatted}\n\n"
                f"Flag Meanings:\n"
                f"FCVAR_UNREGISTERED (1): {bool(flags & FCVAR_UNREGISTERED)}\n"
                f"FCVAR_DEVELOPMENTONLY (2): {bool(flags & FCVAR_DEVELOPMENTONLY)}\n"
                f"FCVAR_GAMEDLL (4): {bool(flags & FCVAR_GAMEDLL)}\n"
                f"FCVAR_CLIENTDLL (8): {bool(flags & FCVAR_CLIENTDLL)}\n"
                f"FCVAR_CHEAT (16): {bool(flags & FCVAR_CHEAT)}\n"
                f"FCVAR_PROTECTED (32): {bool(flags & FCVAR_PROTECTED)}\n"
                f"FCVAR_SPONLY (64): {bool(flags & FCVAR_SPONLY)}\n"
                f"FCVAR_ARCHIVE (128): {bool(flags & FCVAR_ARCHIVE)}\n"
                f"FCVAR_REPLICATED (256): {bool(flags & FCVAR_REPLICATED)}"
            )
            
            # Log the info
            logging.info(f"ConVar Dump:\n{info}")
            
            # Show in a message box
            messagebox.showinfo("ConVar Information", info)
        except Exception as e:
            logging.error(f"Error dumping ConVar info: {str(e)}")
            messagebox.showerror("Error", f"Failed to dump ConVar info: {str(e)}")
    
    def update_status(self, force=False):
        try:
            if sv_cheats_address:
                # Update game process info
                if pm and pm.process_handle:
                    process = psutil.Process(pm.process_id)
                    self.game_label.config(text=f"Game: {process.name()} (PID: {pm.process_id})")
                
                # Update sv_cheats value and flags
                value = pm.read_int(sv_cheats_address + CONVAR_VALUE_OFFSET)
                flags = pm.read_int(sv_cheats_address + CONVAR_FLAGS_OFFSET)
                
                self.value_label.config(text=f"sv_cheats value: {value}")
                self.flags_label.config(text=f"Flags: 0x{flags:X}")
                
                if bypass_active:
                    self.status_label.config(text="Status: BYPASS ACTIVE", fg="green")
                else:
                    self.status_label.config(text="Status: Inactive", fg="black")
            else:
                self.status_label.config(text="Status: ConVar Not Found", fg="red")
        except Exception as e:
            if force:
                logging.error(f"Error updating status: {str(e)}")
                self.status_label.config(text="Status: Error", fg="red")
        
        # Schedule the next update
        self.root.after(1000, self.update_status)
    
    def on_close(self):
        cleanup()
        self.root.destroy()

def main():
    try:
        # Initialize the application
        if not initialize():
            return
        
        # Create the main window
        root = tk.Tk()
        app = SvCheatsApp(root)
        
        # Start the message pump
        root.mainloop()
    except Exception as e:
        logging.error(f"Exception in main: {str(e)}")
        messagebox.showerror("Error", f"An error occurred: {str(e)}")

if __name__ == "__main__":
    main()
    

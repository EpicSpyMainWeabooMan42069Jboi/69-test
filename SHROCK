#include "pch.h"
#include <Windows.h>
#include <cstring>
#include <stdio.h>
#include <Psapi.h>
#include <time.h>
#include <string>
#include <iostream>
#include <fstream>
#include <mutex>
// Removed the problematic include: #include "dllmain.h"

// Forward declarations
class ConVar;
class ICvar;

// Define CreateInterfaceFn type for Source Engine interfaces
using CreateInterfaceFn = void* (*)(const char*, int*);

// Simple color struct for console output
struct Color {
    unsigned char r;
    unsigned char g;
    unsigned char b;
    unsigned char a;
};

// Global variables
ICvar* gI_EngineCvar = nullptr;
bool g_bBypassActive = false;
bool g_bInitialized = false;
std::string g_sNewName;
class SpoofedConvar* g_pSvCheats = nullptr;
HHOOK g_hKeyboardHook = NULL;

// Forward declarations for functions
void DisableSvCheatsSpoof();
void EnableSvCheatsSpoof();
void ToggleSvCheatsSpoof();
bool Initialize();
void Cleanup();
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam);
DWORD WINAPI MainThread(LPVOID lpParam);

// Debug logging
void LogToFile(const char* message) {
    try {
        std::ofstream logFile;
        logFile.open("sv_cheats_bypass_log.txt", std::ios::app);
        if (logFile.is_open()) {
            logFile << message << std::endl;
            logFile.close();
        }
    }
    catch (...) {
        // Silent fail for logging
    }
}

// Utility class for pattern scanning and other helpers
class Utils {
public:
    char* RandomStr(int length) {
        try {
            static const char Alphabets[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
            char* sRet = new char[length + 1];
            int size = sizeof(Alphabets) - 1;
            for (int i = 0; i < length; i++) {
                sRet[i] = Alphabets[rand() % size];
            }
            sRet[length] = '\0';
            return sRet;
        }
        catch (...) {
            LogToFile("Exception in RandomStr");
            return _strdup("fallback");
        }
    }
};

Utils g_Utils;

// ICvar interface definition - Simplified for stability
class ICvar {
public:
    virtual void                   Unknown00() = 0;
    virtual void                   Unknown01() = 0;
    virtual void                   Unknown02() = 0;
    virtual void                   Unknown03() = 0;
    virtual void                   Unknown04() = 0;
    virtual void                   Unknown05() = 0;
    virtual void                   Unknown06() = 0;
    virtual void                   Unknown07() = 0;
    virtual void                   Unknown08() = 0;
    virtual void                   Unknown09() = 0;
    virtual void                   Unknown10() = 0;
    virtual void                   Unknown11() = 0;
    virtual void                   RegisterConCommand(ConVar* pCommandBase) = 0;
    virtual void                   UnregisterConCommand(ConVar* pCommandBase) = 0;
    virtual void                   Unknown14() = 0;
    virtual void                   Unknown15() = 0;
    virtual ConVar* FindVar(const char* var_name) = 0;
    virtual void                   Unknown17() = 0;
    virtual void                   Unknown18() = 0;
    virtual void                   Unknown19() = 0;
    virtual void                   ConsoleColorPrintf(const Color& clr, const char* pFormat, ...) = 0;
};

// ConVar class definition - Simplified for stability
class ConVar {
public:
    void* m_pVMT;
    ConVar* m_pNext;
    bool m_bRegistered;
    const char* m_pszName;
    const char* m_pszHelpString;
    int m_nFlags;
    char pad_0x0018[0x4];
    ConVar* m_pParent;
    const char* m_pszDefaultValue;
    char* m_pszString;
    int m_StringLength;
    float m_fValue;
    int m_nValue;
    bool m_bHasMin;
    float m_fMinVal;
    bool m_bHasMax;
    float m_fMaxVal;
    void* m_fnChangeCallback;

    int GetInt() {
        try {
            return m_nValue;
        }
        catch (...) {
            LogToFile("Exception in GetInt");
            return 0;
        }
    }

    float GetFloat() {
        try {
            return m_fValue;
        }
        catch (...) {
            LogToFile("Exception in GetFloat");
            return 0.0f;
        }
    }

    const char* GetString() {
        try {
            return m_pszString ? m_pszString : "";
        }
        catch (...) {
            LogToFile("Exception in GetString");
            return "";
        }
    }

    const char* GetDefault() {
        try {
            return m_pszDefaultValue ? m_pszDefaultValue : "";
        }
        catch (...) {
            LogToFile("Exception in GetDefault");
            return "";
        }
    }

    void SetValue(int value) {
        try {
            m_nValue = value;
            m_fValue = (float)value;
        }
        catch (...) {
            LogToFile("Exception in SetValue(int)");
        }
    }

    void SetValue(float value) {
        try {
            m_fValue = value;
            m_nValue = (int)value;
        }
        catch (...) {
            LogToFile("Exception in SetValue(float)");
        }
    }

    void SetValue(const char* value) {
        try {
            if (m_pszString) {
                delete[] m_pszString;
            }
            m_pszString = _strdup(value ? value : "");
        }
        catch (...) {
            LogToFile("Exception in SetValue(char*)");
        }
    }
};

// Find ICvar interface - Simplified approach
ICvar* FindCvarInterface() {
    try {
        LogToFile("Looking for ICvar interface...");

        // Try vstdlib.dll first (most common location)
        HMODULE vstdlib = GetModuleHandleA("vstdlib.dll");
        if (!vstdlib) {
            LogToFile("ERROR: vstdlib.dll not found");
            return nullptr;
        }

        CreateInterfaceFn factory = (CreateInterfaceFn)GetProcAddress(vstdlib, "CreateInterface");
        if (!factory) {
            LogToFile("ERROR: CreateInterface not found in vstdlib.dll");
            return nullptr;
        }

        // Try common interface versions
        const char* interfaces[] = {
            "VEngineCvar007",
            "VEngineCvar006",
            "VEngineCvar005",
            "VEngineCvar004",
            "VEngineCvar003"
        };

        for (const char* name : interfaces) {
            ICvar* cvar = (ICvar*)factory(name, nullptr);
            if (cvar) {
                char buffer[256];
                sprintf_s(buffer, "Found ICvar interface: %s", name);
                LogToFile(buffer);
                return cvar;
            }
        }

        LogToFile("ERROR: Failed to find ICvar interface");
        return nullptr;
    }
    catch (...) {
        LogToFile("Exception in FindCvarInterface");
        return nullptr;
    }
}

// Simplified SpoofedConvar class - More robust
class SpoofedConvar {
public:
    SpoofedConvar(const char* szCVar, const char* newName) {
        try {
            m_pOriginalCVar = nullptr;
            m_pDummyCVar = nullptr;
            m_iOriginalFlags = 0;
            memset(m_szOriginalValue, 0, sizeof(m_szOriginalValue));

            if (!gI_EngineCvar) {
                LogToFile("ERROR: ICvar interface is null");
                return;
            }

            m_pOriginalCVar = gI_EngineCvar->FindVar(szCVar);
            if (!m_pOriginalCVar) {
                LogToFile("ERROR: Failed to find original ConVar!");
                return;
            }

            // Just set the value directly without spoofing
            if (m_pOriginalCVar) {
                m_pOriginalCVar->SetValue(1);
                LogToFile("Set sv_cheats to 1 directly");
            }
        }
        catch (...) {
            LogToFile("Exception in SpoofedConvar constructor");
        }
    }

    ~SpoofedConvar() {
        try {
            if (m_pOriginalCVar) {
                m_pOriginalCVar->SetValue(0);
            }
        }
        catch (...) {
            LogToFile("Exception in SpoofedConvar destructor");
        }
    }

    bool IsSpoofed() {
        return m_pOriginalCVar != nullptr;
    }

    void SetInt(int iValue) {
        try {
            if (m_pOriginalCVar) {
                m_pOriginalCVar->SetValue(iValue);
            }
        }
        catch (...) {
            LogToFile("Exception in SetInt");
        }
    }

    int GetInt() {
        try {
            return m_pOriginalCVar ? m_pOriginalCVar->GetInt() : 0;
        }
        catch (...) {
            LogToFile("Exception in GetInt");
            return 0;
        }
    }

private:
    ConVar* m_pOriginalCVar;
    ConVar* m_pDummyCVar;
    int m_iOriginalFlags;
    char m_szOriginalValue[128];
};

// Enable sv_cheats bypass - Simplified version
void EnableSvCheatsSpoof() {
    try {
        LogToFile("Attempting to enable sv_cheats bypass...");

        if (!gI_EngineCvar) {
            LogToFile("ERROR: ICvar interface not initialized");
            return;
        }

        ConVar* sv_cheats = gI_EngineCvar->FindVar("sv_cheats");
        if (!sv_cheats) {
            LogToFile("ERROR: Could not find sv_cheats ConVar");
            return;
        }

        char buffer[256];
        sprintf_s(buffer, "Found sv_cheats ConVar: current value = %d", sv_cheats->GetInt());
        LogToFile(buffer);

        if (!g_pSvCheats) {
            // Generate a random name for the spoofed convar
            char sNewName[32] = "sv_cheats_";
            char* randomPart = g_Utils.RandomStr(5);
            strcat_s(sNewName, 32, randomPart);
            delete[] randomPart;

            g_sNewName = sNewName;

            sprintf_s(buffer, "Creating spoofed ConVar with name: %s", g_sNewName.c_str());
            LogToFile(buffer);

            g_pSvCheats = new SpoofedConvar("sv_cheats", sNewName);

            if (g_pSvCheats && g_pSvCheats->IsSpoofed()) {
                LogToFile("Setting sv_cheats to 1");
                g_pSvCheats->SetInt(1);
                g_bBypassActive = true;

                // Show success message
                MessageBoxA(NULL, "sv_cheats bypass ENABLED", "Success", MB_OK | MB_ICONINFORMATION);
            }
            else {
                LogToFile("ERROR: Failed to spoof sv_cheats ConVar");
                MessageBoxA(NULL, "Failed to enable sv_cheats bypass", "Error", MB_OK | MB_ICONERROR);
            }
        }
    }
    catch (...) {
        LogToFile("Exception in EnableSvCheatsSpoof");
    }
}

// Disable sv_cheats bypass
void DisableSvCheatsSpoof() {
    try {
        LogToFile("Attempting to disable sv_cheats bypass...");

        if (g_pSvCheats && g_pSvCheats->IsSpoofed()) {
            g_pSvCheats->SetInt(0);
            g_bBypassActive = false;

            MessageBoxA(NULL, "sv_cheats bypass DISABLED", "Status", MB_OK | MB_ICONINFORMATION);
        }
        else {
            LogToFile("Cannot disable bypass - sv_cheats not spoofed");
        }
    }
    catch (...) {
        LogToFile("Exception in DisableSvCheatsSpoof");
    }
}

// Toggle function for hotkey
void ToggleSvCheatsSpoof() {
    try {
        LogToFile("Toggle function called");

        if (!g_bBypassActive) {
            EnableSvCheatsSpoof();
        }
        else {
            DisableSvCheatsSpoof();
        }
    }
    catch (...) {
        LogToFile("Exception in ToggleSvCheatsSpoof");
    }
}

// Keyboard hook callback function - Simplified to reduce potential crashes
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    try {
        if (nCode >= 0 && wParam == WM_KEYDOWN) {
            KBDLLHOOKSTRUCT* kbStruct = (KBDLLHOOKSTRUCT*)lParam;

            // Only check for INSERT key to minimize interference
            if (kbStruct->vkCode == VK_INSERT) {
                LogToFile("INSERT key detected!");
                ToggleSvCheatsSpoof();
                return 1; // Prevent other hooks from processing this key
            }
        }
    }
    catch (...) {
        LogToFile("Exception in KeyboardProc");
    }

    return CallNextHookEx(g_hKeyboardHook, nCode, wParam, lParam);
}

// Function to initialize the plugin
bool Initialize() {
    try {
        // Clear log file
        std::ofstream logFile("sv_cheats_bypass_log.txt", std::ios::trunc);
        if (logFile.is_open()) {
            logFile << "Initializing sv_cheats bypass plugin..." << std::endl;
            logFile.close();
        }
        LogToFile("Setting random seed");
        srand((unsigned)time(NULL));

        // Find ICvar interface
        gI_EngineCvar = FindCvarInterface();
        if (!gI_EngineCvar) {
            LogToFile("ERROR: Failed to get ICvar interface!");
            MessageBoxA(NULL, "Failed to get ICvar interface!\nTry checking your game version.", "Error", MB_OK | MB_ICONERROR);
            return false;
        }

        LogToFile("Successfully initialized ICvar interface");

        // Test if we can find sv_cheats cvar
        ConVar* sv_cheats = gI_EngineCvar->FindVar("sv_cheats");
        if (sv_cheats) {
            char buffer[256];
            sprintf_s(buffer, "Found sv_cheats ConVar, current value: %d", sv_cheats->GetInt());
            LogToFile(buffer);
        }
        else {
            LogToFile("WARNING: Could not find sv_cheats ConVar!");
        }

        // Set up keyboard hook for the Insert key
        LogToFile("Setting up keyboard hook");
        g_hKeyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);
        if (g_hKeyboardHook == NULL) {
            LogToFile("ERROR: Failed to set keyboard hook!");
            MessageBoxA(NULL, "Failed to set keyboard hook!", "Error", MB_OK | MB_ICONERROR);
            return false;
        }

        LogToFile("Keyboard hook set up successfully");

        // Show a message box to indicate successful initialization
        MessageBoxA(NULL, "sv_cheats Bypass Plugin Loaded!\nPress INSERT key to toggle bypass.", "Plugin Loaded", MB_OK | MB_ICONINFORMATION);

        return true;
    }
    catch (...) {
        LogToFile("Exception in Initialize");
        return false;
    }
}

// Function to clean up
void Cleanup() {
    try {
        LogToFile("Cleaning up resources");

        // Disable the bypass if active
        if (g_bBypassActive) {
            DisableSvCheatsSpoof();
        }

        // Clean up the spoofed convar
        delete g_pSvCheats;
        g_pSvCheats = nullptr;

        // Unhook keyboard hook
        if (g_hKeyboardHook != NULL) {
            UnhookWindowsHookEx(g_hKeyboardHook);
            g_hKeyboardHook = NULL;
        }

        LogToFile("Cleanup complete");
    }
    catch (...) {
        LogToFile("Exception in Cleanup");
    }
}

// Thread function for the DLL to run continuously
DWORD WINAPI MainThread(LPVOID lpParam) {
    try {
        // Initialize the plugin
        if (!Initialize()) {
            return 1;
        }

        g_bInitialized = true;
        LogToFile("Main thread initialized successfully");

        // Message loop to keep the thread alive and process keyboard events
        MSG msg;
        LogToFile("Entering message loop");
        while (GetMessage(&msg, NULL, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    catch (...) {
        LogToFile("Exception in MainThread");
    }

    return 0;
}

// DLL entry point
BOOL APIENTRY DllMain(HMODULE hModule, DWORD reason, LPVOID lpReserved) {
    if (reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);

        // Create a thread with a larger stack size to avoid stack overflows
        HANDLE hThread = CreateThread(NULL, 1024 * 1024, MainThread, hModule, 0, NULL);
        if (hThread) {
            CloseHandle(hThread);
        }
    }
    else if (reason == DLL_PROCESS_DETACH) {
        if (g_bInitialized) {
            Cleanup();
        }
    }

    return TRUE;
}

#include "pch.h"
#include <Windows.h>
#include <cstring>
#include <stdio.h>
#include <Psapi.h>
#include <time.h>
#include <string>
#include <iostream>
#include <fstream>

// Forward declarations
class ConVar;
class ICvar;

// Define CreateInterfaceFn type for Source Engine interfaces
using CreateInterfaceFn = void* (*)(const char*, int*);

// Simple color struct for console output
struct Color {
    unsigned char r;
    unsigned char g;
    unsigned char b;
    unsigned char a;
};

// Global variables
ICvar* gI_EngineCvar = nullptr;
bool g_bBypassActive = false;
bool g_bInitialized = false;
std::string g_sNewName;
class SpoofedConvar* g_pSvCheats = nullptr;
HHOOK g_hKeyboardHook = NULL;

// Debug logging
void LogToFile(const char* message) {
    std::ofstream logFile;
    logFile.open("sv_cheats_bypass_log.txt", std::ios::app);
    if (logFile.is_open()) {
        logFile << message << std::endl;
        logFile.close();
    }
}

// Utility class for pattern scanning and other helpers
class Utils {
public:
    uintptr_t FindPattern(const char* szModule, const char* szSignature) {
        MODULEINFO modInfo;
        GetModuleInformation(GetCurrentProcess(), GetModuleHandleA(szModule), &modInfo, sizeof(MODULEINFO));
        uintptr_t startAddress = reinterpret_cast<uintptr_t>(modInfo.lpBaseOfDll);
        uintptr_t endAddress = startAddress + modInfo.SizeOfImage;
        const char* pat = szSignature;
        uintptr_t firstMatch = 0;
        for (uintptr_t pCur = startAddress; pCur < endAddress; pCur++) {
            if (!*pat) return firstMatch;
            if (*(PBYTE)pat == '\?' || *(BYTE*)pCur == getByte(pat)) {
                if (!firstMatch) firstMatch = pCur;
                if (!pat[2]) return firstMatch;
                if (*(PWORD)pat == '\?\?' || *(PBYTE)pat != '\?') pat += 3;
                else pat += 2;
            }
            else {
                pat = szSignature;
                firstMatch = 0;
            }
        }
        return NULL;
    }

    char* RandomStr(int length) {
        static const char Alphabets[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        char* sRet = new char[length + 1];
        int size = sizeof(Alphabets) - 1;
        for (int i = 0; i < length; i++) {
            sRet[i] = Alphabets[rand() % size];
            sRet[i + 1] = '\0';
        }
        return sRet;
    }

private:
    unsigned char getBits(unsigned char x) {
        if ((x & (~0x20)) >= 'A' && (x & (~0x20)) <= 'F')
            return ((x & (~0x20)) - 'A' + 0xA);
        else if (x >= '0' && x <= '9')
            return x - '0';
        return 0;
    }

    unsigned char getByte(const char* x) {
        return (getBits(x[0]) << 4 | getBits(x[1]));
    }
};

Utils g_Utils;

// ICvar interface definitions
class ICvar {
public:
    virtual void RegisterConCommand(ConVar* pCommandBase) = 0;
    virtual void UnregisterConCommand(ConVar* pCommandBase) = 0;
    virtual ConVar* FindVar(const char* var_name) = 0;
    virtual void ConsoleColorPrintf(const Color& clr, const char* pFormat, ...) = 0;
};

// ConVar class definition
class ConVar {
public:
    void* m_pVMT;
    ConVar* m_pNext;
    bool m_bRegistered;
    const char* m_pszName;
    const char* m_pszHelpString;
    int m_nFlags;
    char pad_0x0018[0x4];
    ConVar* m_pParent;
    const char* m_pszDefaultValue;
    char* m_pszString;
    int m_StringLength;
    float m_fValue;
    int m_nValue;
    bool m_bHasMin;
    float m_fMinVal;
    bool m_bHasMax;
    float m_fMaxVal;
    void* m_fnChangeCallback;

    int GetInt() {
        return m_nValue;
    }

    float GetFloat() {
        return m_fValue;
    }

    const char* GetString() {
        return m_pszString;
    }

    const char* GetDefault() {
        return m_pszDefaultValue;
    }

    void SetValue(int value) {
        m_nValue = value;
        m_fValue = (float)value;
    }

    void SetValue(float value) {
        m_fValue = value;
        m_nValue = (int)value;
    }

    void SetValue(const char* value) {
        if (m_pszString) {
            delete[] m_pszString;
        }
        m_pszString = _strdup(value);
    }
};

// SpoofedConvar class implementation
class SpoofedConvar {
public:
    SpoofedConvar(const char* szCVar, const char* newName) {
        m_pOriginalCVar = gI_EngineCvar->FindVar(szCVar);
        if (!m_pOriginalCVar) {
            LogToFile("ERROR: Failed to find original ConVar!");
            return;
        }
        Spoof(newName);
    }

    SpoofedConvar(ConVar* pCVar, const char* newName) {
        m_pOriginalCVar = pCVar;
        Spoof(newName);
    }

    ~SpoofedConvar() {
        if (IsSpoofed()) {
            DWORD dwOld;

            // Restore flags
            SetFlags(m_iOriginalFlags);
            // Restore value
            SetString(m_szOriginalValue);
            // Restore the name
            VirtualProtect((LPVOID)m_pOriginalCVar->m_pszName, 128, PAGE_READWRITE, &dwOld);
            strcpy_s((char*)m_pOriginalCVar->m_pszName, 128, m_szOriginalName);
            VirtualProtect((LPVOID)m_pOriginalCVar->m_pszName, 128, dwOld, &dwOld);

            // Unregister dummy cvar
            gI_EngineCvar->UnregisterConCommand(m_pDummyCVar);
            free(m_pDummyCVar);
            m_pDummyCVar = nullptr;
        }
    }

    bool IsSpoofed() {
        return m_pDummyCVar != nullptr;
    }

    void Spoof(const char* newName) {
        if (!IsSpoofed() && m_pOriginalCVar) {
            // Save old name value and flags so we can restore the cvar later if needed
            m_iOriginalFlags = m_pOriginalCVar->m_nFlags;
            strcpy_s(m_szOriginalName, sizeof(m_szOriginalName), m_pOriginalCVar->m_pszName);
            strcpy_s(m_szOriginalValue, sizeof(m_szOriginalValue), m_pOriginalCVar->GetDefault());

            sprintf_s(m_szDummyName, 128, "%s", newName);

            // Create the dummy cvar
            m_pDummyCVar = (ConVar*)malloc(sizeof(ConVar));
            if (!m_pDummyCVar) {
                LogToFile("ERROR: Failed to allocate memory for dummy ConVar!");
                return;
            }

            memcpy(m_pDummyCVar, m_pOriginalCVar, sizeof(ConVar));

            m_pDummyCVar->m_pNext = nullptr;
            // Register it
            gI_EngineCvar->RegisterConCommand(m_pDummyCVar);

            // Fix "write access violation" issue
            DWORD dwOld;
            VirtualProtect((LPVOID)m_pOriginalCVar->m_pszName, 128, PAGE_READWRITE, &dwOld);
            // Rename the cvar
            strcpy_s((char*)m_pOriginalCVar->m_pszName, 128, m_szDummyName);
            VirtualProtect((LPVOID)m_pOriginalCVar->m_pszName, 128, dwOld, &dwOld);

            SetFlags(0); // FCVAR_NONE

            LogToFile("Successfully spoofed ConVar");
        }
    }

    void SetFlags(int flags) {
        if (IsSpoofed()) {
            m_pOriginalCVar->m_nFlags = flags;
        }
    }

    int GetFlags() {
        return IsSpoofed() ? m_pOriginalCVar->m_nFlags : 0;
    }

    void SetInt(int iValue) {
        if (IsSpoofed()) {
            m_pOriginalCVar->SetValue(iValue);
        }
    }

    void SetFloat(float flValue) {
        if (IsSpoofed()) {
            m_pOriginalCVar->SetValue(flValue);
        }
    }

    void SetString(const char* szValue) {
        if (IsSpoofed()) {
            m_pOriginalCVar->SetValue(szValue);
        }
    }

    int GetInt() {
        return IsSpoofed() ? m_pOriginalCVar->GetInt() : 0;
    }

    float GetFloat() {
        return IsSpoofed() ? m_pOriginalCVar->GetFloat() : 0.0f;
    }

    const char* GetString() {
        return IsSpoofed() ? m_pOriginalCVar->GetString() : "";
    }

private:
    ConVar* m_pOriginalCVar = nullptr;
    ConVar* m_pDummyCVar = nullptr;

    char m_szDummyName[128];
    char m_szDummyValue[128];
    char m_szOriginalName[128];
    char m_szOriginalValue[128];
    int m_iOriginalFlags;
};

// Forward declaration for DisableSvCheatsSpoof
void DisableSvCheatsSpoof();

// Command to execute in game console
void ExecuteCommand(const char* cmd) {
    typedef void (*ExecuteCommandFn)(const char*);

    // Try to find the function pointer using common patterns
    // This is a simplistic approach - may need to be adjusted for TF2 specifically
    uintptr_t engineBase = (uintptr_t)GetModuleHandleA("engine.dll");
    if (!engineBase) {
        LogToFile("ERROR: Failed to get engine.dll base address");
        return;
    }

    // Execute the command through different methods

    // Method 1: Try to find and use engine client interface
    void* engineClient = NULL;
    HMODULE engineModule = GetModuleHandleA("engine.dll");
    if (engineModule) {
        CreateInterfaceFn interfaceFactory = (CreateInterfaceFn)GetProcAddress(engineModule, "CreateInterface");
        if (interfaceFactory) {
            const char* possibleInterfaces[] = {
                "VEngineClient013",
                "VEngineClient014",
                "VEngineClient015",
                "VEngineClient016",
                "VEngineClient017"
            };

            for (const char* interfaceName : possibleInterfaces) {
                engineClient = interfaceFactory(interfaceName, nullptr);
                if (engineClient) break;
            }
        }
    }

    // If we have engine client, try to execute command through it
    if (engineClient) {
        typedef void(__thiscall* ExecuteCommandInClientFn)(void*, const char*);
        void** vtable = *(void***)engineClient;

        // Common vtable offset for ExecuteClientCmd - may need adjustment
        ExecuteCommandInClientFn executeClientCmd = (ExecuteCommandInClientFn)vtable[108];

        try {
            executeClientCmd(engineClient, cmd);
            char buffer[256];
            sprintf_s(buffer, "Executed command using EngineClient: %s", cmd);
            LogToFile(buffer);
        }
        catch (...) {
            LogToFile("ERROR: Exception while executing command through EngineClient");
        }
    }

    // Method 2: Find sv_cheats ConVar and modify it directly if we need to
    ConVar* sv_cheats = gI_EngineCvar->FindVar("sv_cheats");
    if (sv_cheats) {
        char buffer[256];
        sprintf_s(buffer, "Found sv_cheats: current value = %d", sv_cheats->GetInt());
        LogToFile(buffer);
    }
}

void EnableSvCheatsSpoof() {
    LogToFile("Attempting to enable sv_cheats bypass...");

    // First try to find if sv_cheats exists at all and log the result
    ConVar* sv_cheats_test = gI_EngineCvar->FindVar("sv_cheats");
    if (!sv_cheats_test) {
        LogToFile("ERROR: FindVar(\"sv_cheats\") returned nullptr!");

        // Try alternative spellings or formats
        sv_cheats_test = gI_EngineCvar->FindVar("sv__cheats");
        if (sv_cheats_test) {
            LogToFile("Found ConVar with alternative name: sv__cheats");
        }
        else {
            sv_cheats_test = gI_EngineCvar->FindVar("sv_cheat");
            if (sv_cheats_test) {
                LogToFile("Found ConVar with alternative name: sv_cheat");
            }
            else {
                // List some of the available cvars for debugging
                LogToFile("Listing some available ConVars:");
                // This would require access to ConVar list which we don't have directly
                // We could try to guess some common ConVars
                const char* common_cvars[] = {
                    "cl_interp", "host_timescale", "r_drawothermodels", "cl_cmdrate", "sv_gravity"
                };
                for (const char* cvar : common_cvars) {
                    ConVar* test = gI_EngineCvar->FindVar(cvar);
                    if (test) {
                        char buffer[256];
                        sprintf_s(buffer, "Found ConVar: %s = %s", cvar, test->GetString());
                        LogToFile(buffer);
                    }
                }

                MessageBoxA(NULL, "Could not find sv_cheats ConVar! See log for details.", "Error", MB_OK | MB_ICONERROR);
                return;
            }
        }
    }
    else {
        char buffer[256];
        sprintf_s(buffer, "Found sv_cheats ConVar: current value = %d", sv_cheats_test->GetInt());
        LogToFile(buffer);
    }

    if (!g_pSvCheats) {
        char* sNewName = new char[32];
        strcpy_s(sNewName, 32, "sv_cheats_");
        strcat_s(sNewName, 32, g_Utils.RandomStr(5));
        g_sNewName = sNewName;

        // Fixed line - using sprintf_s to format the string before logging
        char buffer[256];
        sprintf_s(buffer, "Creating spoofed ConVar with name: %s", g_sNewName.c_str());
        LogToFile(buffer);

        g_pSvCheats = new SpoofedConvar("sv_cheats", sNewName);

        if (g_pSvCheats && g_pSvCheats->IsSpoofed()) {
            Color successColor;
            successColor.r = 0;
            successColor.g = 255;
            successColor.b = 0;
            successColor.a = 255;

            // Use multiple console print methods for redundancy
            if (gI_EngineCvar) {
                gI_EngineCvar->ConsoleColorPrintf(successColor, "[PLUGIN] sv_cheats renamed to: %s\n", sNewName);
            }

            LogToFile("Setting spoofed convar value to 1");
            g_pSvCheats->SetInt(1);

            // Execute a command that requires sv_cheats to test
            ExecuteCommand("echo [PLUGIN] Testing sv_cheats bypass...");
            ExecuteCommand("r_drawothermodels 2"); // This command requires sv_cheats

            // Create a fake ConVar to handle checks
            ConVar* newFakeCvar = (ConVar*)malloc(sizeof(ConVar));
            if (newFakeCvar) {
                memset(newFakeCvar, 0, sizeof(ConVar));

                // Set up the fake ConVar similar to original sv_cheats
                newFakeCvar->m_pszName = _strdup("sv_cheats");
                newFakeCvar->m_pszDefaultValue = _strdup("0");
                newFakeCvar->m_nFlags = 0;

                gI_EngineCvar->RegisterConCommand(newFakeCvar);

                LogToFile("Created fake sv_cheats ConVar");
            }
            else {
                LogToFile("ERROR: Failed to allocate memory for fake ConVar");
            }
            g_bBypassActive = true;

            if (gI_EngineCvar) {
                gI_EngineCvar->ConsoleColorPrintf(successColor, "[PLUGIN] sv_cheats bypass ENABLED (Clientside only)\n");
            }

            // Execute another visible command to show it's working
            ExecuteCommand("echo [PLUGIN] sv_cheats bypass is now ACTIVE - you can use cheat commands!");

            // Create a message box to indicate success
            MessageBoxA(NULL, "sv_cheats bypass ENABLED", "Success", MB_OK | MB_ICONINFORMATION);
        }
        else {
            LogToFile("ERROR: Failed to spoof sv_cheats ConVar");
            MessageBoxA(NULL, "Failed to enable sv_cheats bypass", "Error", MB_OK | MB_ICONERROR);
        }
    }
}

void DisableSvCheatsSpoof() {
    LogToFile("Attempting to disable sv_cheats bypass...");

    if (g_pSvCheats && g_pSvCheats->IsSpoofed()) {
        g_pSvCheats->SetInt(0);
        g_bBypassActive = false;

        Color infoColor;
        infoColor.r = 255;
        infoColor.g = 165;
        infoColor.b = 0;
        infoColor.a = 255;

        gI_EngineCvar->ConsoleColorPrintf(infoColor, "[PLUGIN] sv_cheats bypass DISABLED\n");

        MessageBoxA(NULL, "sv_cheats bypass DISABLED", "Status", MB_OK | MB_ICONINFORMATION);
    }
    else {
        LogToFile("Cannot disable bypass - sv_cheats not spoofed");
    }
}

// Toggle function for hotkey
void ToggleSvCheatsSpoof() {
    LogToFile("Toggle function called");

    if (!g_bBypassActive) {
        EnableSvCheatsSpoof();
    }
    else {
        DisableSvCheatsSpoof();
    }
}

// Keyboard hook callback function
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0) {
        if (wParam == WM_KEYDOWN) {
            KBDLLHOOKSTRUCT* kbStruct = (KBDLLHOOKSTRUCT*)lParam;

            // Log all key presses for debugging
            char keyBuffer[64];
            sprintf_s(keyBuffer, "Key pressed: %d", kbStruct->vkCode);
            LogToFile(keyBuffer);

            // VK_INSERT is the virtual key code for the Insert key
            if (kbStruct->vkCode == VK_INSERT) {
                LogToFile("INSERT key detected!");
                ToggleSvCheatsSpoof();
                return 1; // Prevent other hooks from processing this key
            }

            // Alternative hotkey (HOME key) as backup
            if (kbStruct->vkCode == VK_HOME) {
                LogToFile("HOME key detected as alternative hotkey!");
                ToggleSvCheatsSpoof();
                return 1;
            }
        }
    }
    return CallNextHookEx(g_hKeyboardHook, nCode, wParam, lParam);
}

// Function to check if a cvar exists (diagnostic tool)
bool DoesCvarExist(const char* name) {
    if (!gI_EngineCvar) return false;
    ConVar* var = gI_EngineCvar->FindVar(name);
    return var != nullptr;
}

// Function to dump available ConVars to log (diagnostic tool)
void DumpCommonCvars() {
    const char* common_cvars[] = {
        "sv_cheats", "sv_allowcheats", "sv_consistency", "sv_lan",
        "host_timescale", "r_drawothermodels", "cl_showfps",
        "cl_cmdrate", "cl_updaterate", "rate", "fps_max",
        "hurtme", "addcond 66", "sv_gravity"
    };

    LogToFile("==== Dumping Common ConVars ====");

    for (const char* cvar : common_cvars) {
        if (DoesCvarExist(cvar)) {
            ConVar* var = gI_EngineCvar->FindVar(cvar);
            char buffer[256];
            sprintf_s(buffer, "ConVar %s exists: value=%s, flags=0x%X",
                cvar, var->GetString(), var->m_nFlags);
            LogToFile(buffer);
        }
        else {
            char buffer[256];
            sprintf_s(buffer, "ConVar %s does not exist", cvar);
            LogToFile(buffer);
        }
    }

    LogToFile("==== End of ConVar Dump ====");
}

// Enhanced interface finding with fallback options
ICvar* FindCvarInterface() {
    // Try multiple DLLs that might contain the interface
    const char* possible_modules[] = {
        "engine.dll", "vstdlib.dll", "tier0.dll", "client.dll", "materialsystem.dll"
    };

    // Interface names to try (from newest to oldest)
    const char* possible_interfaces[] = {
        "VEngineCvar007", "VEngineCvar006", "VEngineCvar005", "VEngineCvar004",
        "VEngineCvar003", "VEngineCvar002", "VEngineCvar001",
        "VCvar007", "VCvar006", "VCvar005", "VCvar004", "VCvar003", "VCvar002", "VCvar001"
    };

    for (const char* module_name : possible_modules) {
        HMODULE module = GetModuleHandleA(module_name);
        if (!module) continue;

        char buffer[256];
        sprintf_s(buffer, "Trying to find interface in %s", module_name);
        LogToFile(buffer);

        CreateInterfaceFn factory = (CreateInterfaceFn)GetProcAddress(module, "CreateInterface");
        if (!factory) continue;

        for (const char* interface_name : possible_interfaces) {
            ICvar* cvar_interface = reinterpret_cast<ICvar*>(factory(interface_name, nullptr));
            if (cvar_interface) {
                sprintf_s(buffer, "Found ICvar interface %s in %s", interface_name, module_name);
                LogToFile(buffer);
                return cvar_interface;
            }
        }
    }

    return nullptr;
}

// Function to initialize the plugin
bool Initialize() {
    // Clear log file
    std::ofstream logFile("sv_cheats_bypass_log.txt", std::ios::trunc);
    if (logFile.is_open()) {
        logFile << "Initializing sv_cheats bypass plugin..." << std::endl;
        logFile.close();
    }

    LogToFile("Setting random seed");
    srand((unsigned)time(NULL));

    // Enhanced interface finding
    gI_EngineCvar = FindCvarInterface();

    if (!gI_EngineCvar) {
        LogToFile("ERROR: Failed to get ICvar interface through enhanced search!");

        // Get the name of the process we're injected into
        char processName[MAX_PATH] = "unknown";
        GetModuleFileNameA(NULL, processName, MAX_PATH);
        char* filename = strrchr(processName, '\\');
        if (filename) {
            filename++; // Skip the backslash
        }
        else {
            filename = processName;
        }

        char errorMsg[512];
        sprintf_s(errorMsg, "Failed to get ICvar interface!\n\nProcess: %s\n\nTry checking your game version or using a different interface version.", filename);
        LogToFile("ERROR: Failed to get ICvar interface!");
        LogToFile(errorMsg);
        MessageBoxA(NULL, errorMsg, "Error", MB_OK | MB_ICONERROR);
        return false;
    }

    LogToFile("Successfully initialized ICvar interface");

    // Enhanced diagnostics - dump common ConVars
    DumpCommonCvars();

    // Test if we can find sv_cheats cvar
    ConVar* sv_cheats = gI_EngineCvar->FindVar("sv_cheats");
    if (sv_cheats) {
        char buffer[256];
        sprintf_s(buffer, "Found sv_cheats ConVar, current value: %d, flags: 0x%X",
            sv_cheats->GetInt(), sv_cheats->m_nFlags);
        LogToFile(buffer);
    }
    else {
        LogToFile("WARNING: Could not find sv_cheats ConVar! Will try direct memory access.");

        // Try alternate names or patterns
        const char* alt_names[] = { "sv__cheats", "sv_cheat", "svcheats", "sv-cheats" };
        for (const char* name : alt_names) {
            ConVar* alt_cvar = gI_EngineCvar->FindVar(name);
            if (alt_cvar) {
                char buffer[256];
                sprintf_s(buffer, "Found alternative ConVar: %s = %d", name, alt_cvar->GetInt());
                LogToFile(buffer);
            }
        }
    }

    // Display welcome message in console
    Color welcomeColor;
    welcomeColor.r = 0;
    welcomeColor.g = 255;
    welcomeColor.b = 0;
    welcomeColor.a = 255;

    if (gI_EngineCvar) {
        gI_EngineCvar->ConsoleColorPrintf(welcomeColor, "====================================\n");
        gI_EngineCvar->ConsoleColorPrintf(welcomeColor, " sv_cheats Bypass Plugin Loaded!\n");
        gI_EngineCvar->ConsoleColorPrintf(welcomeColor, " Press INSERT key to toggle bypass\n");
        gI_EngineCvar->ConsoleColorPrintf(welcomeColor, " Alternative key: HOME\n");
        gI_EngineCvar->ConsoleColorPrintf(welcomeColor, "====================================\n");
    }

    // Execute a command in console
    ExecuteCommand("echo ====================================");
    ExecuteCommand("echo  sv_cheats Bypass Plugin Loaded!");
    ExecuteCommand("echo  Press INSERT key to toggle bypass");
    ExecuteCommand("echo  Alternative key: HOME");
    ExecuteCommand("echo ====================================");

    // Set up keyboard hook for the Insert key
    LogToFile("Setting up keyboard hook");
    g_hKeyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);
    if (g_hKeyboardHook == NULL) {
        LogToFile("ERROR: Failed to set keyboard hook!");
        MessageBoxA(NULL, "Failed to set keyboard hook!", "Error", MB_OK | MB_ICONERROR);
        return false;
    }

    LogToFile("Keyboard hook set up successfully");

    // Show a message box to indicate successful initialization
    MessageBoxA(NULL, "sv_cheats Bypass Plugin Loaded!\nPress INSERT key or HOME key to toggle bypass.", "Plugin Loaded", MB_OK | MB_ICONINFORMATION);

    return true;
}

// Function to clean up
void Cleanup() {
    LogToFile("Cleaning up resources");

    // Disable the bypass if active
    if (g_bBypassActive) {
        DisableSvCheatsSpoof();
    }

    // Clean up the spoofed convar
    delete g_pSvCheats;
    g_pSvCheats = nullptr;

    // Unhook keyboard hook
    if (g_hKeyboardHook != NULL) {
        UnhookWindowsHookEx(g_hKeyboardHook);
        g_hKeyboardHook = NULL;
    }

    LogToFile("Cleanup complete");
}

// Thread function for the DLL to run continuously
DWORD WINAPI MainThread(LPVOID lpParam) {
    // Initialize the plugin
    if (!Initialize()) {
        return 1;
    }

    g_bInitialized = true;
    LogToFile("Main thread initialized successfully");

    // Enable bypass automatically at startup
    LogToFile("Automatically enabling bypass at startup");
    ToggleSvCheatsSpoof();

    // Message loop to keep the thread alive and process keyboard events
    MSG msg;
    LogToFile("Entering message loop");
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}

// DLL entry point
BOOL APIENTRY DllMain(HMODULE hModule, DWORD reason, LPVOID lpReserved) {
    if (reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hModule);
        CreateThread(NULL, 0, MainThread, hModule, 0, NULL);
    }
    else if (reason == DLL_PROCESS_DETACH) {
        if (g_bInitialized) {
            Cleanup();
        }
    }
    return TRUE;
} // 👈 this ends DllMain, you're done here
